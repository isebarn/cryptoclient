/* Copyright (c) 2012 nao yonamine */
!(function (a) {
  'use strict'; const b = function () { return r.apply(null, arguments) }; const c = Array.prototype.slice; const d = 0; const e = 1; const f = 2; const g = 3; const h = [8e3, 11025, 12e3, 16e3, 22050, 24e3, 32e3, 44100, 48e3]; const i = [32, 64, 128, 256]; const j = '14.10.12'; let k = null; const l = {}; const m = {}; const n = typeof window !== 'undefined' ? 'browser' : typeof module !== 'undefined' && module.exports ? 'node' : 'unknown'; const o = n === 'browser' && /(iPhone|iPad|iPod|Android)/i.test(navigator.userAgent); let p = !1; let q = 120; var r = function () { let b; let d; const e = c.call(arguments); let f = e[0]; switch (typeof f) { case 'string':l[f] ? b = new l[f](e.slice(1)) : m[f] ? b = m[f](e.slice(1)) : (d = /^(.+?)(?:\.(ar|kr))?$/.exec(f), d && (f = d[1], l[f] ? b = new l[f](e.slice(1)) : m[f] && (b = m[f](e.slice(1))), b && d[2] && b[d[2]]())); break; case 'number':b = new D(e); break; case 'boolean':b = new E(e); break; case 'function':b = new F(e); break; case 'object':if (f !== null) { if (f instanceof A) { return f } if (f.context instanceof A) { return f.context } v(f) ? b = new H(e) : u(f) && (b = new G(e)) } }b === a && (b = new C(e.slice(1)), console.warn('T("' + f + '") is not defined.')); const g = b._; return g.originkey = f, g.meta = s(b), g.emit('init'), b }; var s = function (a) { for (var b, c, d = a._.meta, e = a; e !== null && e.constructor !== Object;) { b = Object.getOwnPropertyNames(e); for (let f = 0, g = b.length; g > f; ++f) { d[b[f]] || (/^(constructor$|process$|_)/.test(b[f]) ? d[b[f]] = 'ignore' : (c = Object.getOwnPropertyDescriptor(e, b[f]), typeof c.value === 'function' ? d[b[f]] = 'function' : (c.get || c.set) && (d[b[f]] = 'property'))) }e = Object.getPrototypeOf(e) } return d }; Object.defineProperties(b, { version: { value: j }, envtype: { value: n }, envmobile: { value: o }, env: { get () { return k.impl.env } }, samplerate: { get () { return k.samplerate } }, channels: { get () { return k.channels } }, cellsize: { get () { return k.cellsize } }, currentTime: { get () { return k.currentTime } }, isPlaying: { get () { return k.status === e } }, isRecording: { get () { return k.status === g } }, amp: { set (a) { typeof a === 'number' && (k.amp = a) }, get () { return k.amp } }, bpm: { set (a) { typeof a === 'number' && a >= 5 && a <= 300 && (q = a) }, get () { return q } } }), b.bind = function (a, c) { return k.bind(a, c), b }, b.setup = function (a) { return k.setup(a), b }, b.play = function () { return k.play(), b }, b.pause = function () { return k.pause(), b }, b.reset = function () { return k.reset(), k.events.emit('reset'), b }, b.on = b.addListener = function (a, c) { return k.on(a, c), b }, b.once = function (a, c) { return k.once(a, c), b }, b.off = b.removeListener = function (a, c) { return k.off(a, c), b }, b.removeAllListeners = function (a) { return k.removeAllListeners(a), b }, b.listeners = function (a) { return k.listeners(a) }, b.rec = function () { return k.rec.apply(k, arguments) }, b.timevalue = (function () { const a = function (a) { let b; let c = q; return (b = /^bpm(\d+(?:\.\d+)?)/i.exec(a)) && (c = Math.max(5, Math.min(300, +(b[1] || 0)))), c }; return function (c) { let d, e, f; if (d = /^(\d+(?:\.\d+)?)Hz$/i.exec(c)) { return +d[1] === 0 ? 0 : 1e3 / +d[1] } if (d = /L(\d+)?(\.*)$/i.exec(c)) { return e = 60 / a(c) * (4 / (d[1] || 4)) * 1e3, e *= [1, 1.5, 1.75, 1.875][(d[2] || '').length] || 1 } if (d = /^(\d+(?:\.\d+)?|\.(?:\d+))(min|sec|m)s?$/i.exec(c)) { switch (d[2]) { case 'min':return 60 * +(d[1] || 0) * 1e3; case 'sec':return 1e3 * +(d[1] || 0); case 'm':return +(d[1] || 0) } } return (d = /^(?:([0-5]?[0-9]):)?(?:([0-5]?[0-9]):)(?:([0-5]?[0-9]))(?:\.([0-9]{1,3}))?$/.exec(c)) ? (f = 3600 * (d[1] || 0) + 60 * (d[2] || 0) + (d[3] || 0), f = 1e3 * f + (0 | ((d[4] || '') + '00').substr(0, 3))) : (d = /(\d+)\.(\d+)\.(\d+)$/i.exec(c)) ? (f = 480 * (4 * d[1] + +d[2]) + +d[3], 60 / a(c) * (f / 480) * 1e3) : (d = /(\d+)ticks$/i.exec(c)) ? 60 / a(c) * (d[1] / 480) * 1e3 : (d = /^(\d+)samples(?:\/(\d+)Hz)?$/i.exec(c)) ? 1e3 * d[1] / (d[2] || b.samplerate) : 0 } }()); const t = b.fn = { SignalArray: Float32Array, currentTimeIncr: 0, emptycell: null, FINISHED_STATE: d, PLAYING_STATE: e, UNSCHEDULED_STATE: f, SCHEDULED_STATE: g }; var u = t.isArray = Array.isArray; var v = t.isDictionary = function (a) { return typeof a === 'object' && a.constructor === Object }; t.nop = function () { return this }, t.isSignalArray = function (a) { return a instanceof t.SignalArray ? !0 : Array.isArray(a) && a.__klass && a.__klass.type === 2 ? !0 : !1 }, t.extend = function (a, b) { function c () { this.constructor = a }b = b || A; for (const d in b) { b.hasOwnProperty(d) && (a[d] = b[d]) } return c.prototype = b.prototype, a.prototype = new c(), a.__super__ = b.prototype, a }, t.constructorof = function (a, b) { for (let c = a && a.prototype; c;) { if (c === b.prototype) { return !0 } c = Object.getPrototypeOf(c) } return !1 }, t.register = function (a, b) { t.constructorof(b, A) ? l[a] = b : m[a] = b }, t.alias = function (a, b) { l[b] ? l[a] = l[b] : m[b] && (m[a] = m[b]) }, t.getClass = function (a) { return l[a] }, t.pointer = function (a, b, c) { return b = a.byteOffset + b * a.constructor.BYTES_PER_ELEMENT, typeof c === 'number' ? new a.constructor(a.buffer, b, c) : new a.constructor(a.buffer, b) }, t.nextTick = function (a) { return k.nextTick(a), b }, t.fixAR = function (a) { a._.ar = !0, a._.aronly = !0 }, t.fixKR = function (a) { a._.ar = !1, a._.kronly = !0 }, t.changeWithValue = function () { const a = this._; let b = a.value * a.mul + a.add; isNaN(b) && (b = 0); for (let c = this.cells[0], d = 0, e = c.length; e > d; ++d) { c[d] = b } }, t.changeWithValue.unremovable = !0, t.clone = function (a) { const b = new a.constructor([]); return b._.ar = a._.ar, b._.mul = a._.mul, b._.add = a._.add, b._.bypassed = a._.bypassed, b }, t.timer = (function () { const a = function (a) { return function () { !k.timers.includes(a) && (k.timers.push(a), k.events.emit('addObject'), a._.emit('start'), t.buddies_start(a)) } }; const b = function (a) { return function () { const b = k.timers.indexOf(a); b !== -1 && (k.timers.splice(b, 1), a._.emit('stop'), k.events.emit('removeObject'), t.buddies_stop(a)) } }; return function (c) { const d = a(c); const e = b(c); return c.nodeType = A.TIMER, c.start = function () { return k.nextTick(d), c }, c.stop = function () { return k.nextTick(e), c }, c } }()), t.listener = (function () { const a = function (a) { return function () { !k.listeners.includes(a) && (k.listeners.push(a), k.events.emit('addObject'), a._.emit('listen'), t.buddies_start(a)) } }; const b = function (a) { return function () { const b = k.listeners.indexOf(a); b !== -1 && (k.listeners.splice(b, 1), a._.emit('unlisten'), k.events.emit('removeObject'), t.buddies_stop(a)) } }; return function (c) { const d = a(c); const e = b(c); return c.nodeType = A.LISTENER, c.listen = function () { return arguments.length && c.append.apply(c, arguments), c.nodes.length && k.nextTick(d), c }, c.unlisten = function () { return arguments.length && c.remove.apply(c, arguments), c.nodes.length || k.nextTick(e), c }, c } }()), t.make_onended = function (a, b) { return function () { if (a.playbackState = d, typeof b === 'number') { for (let c = a.cells[0], e = a.cells[1], f = a.cells[2], g = 0, h = e.length; h > g; ++g) { c[0] = e[g] = f[g] = b } }a._.emit('ended') } }, t.inputSignalAR = function (a) { let b; let c; let d; let f; let g; let h; const i = a.cells[0]; const j = a.cells[1]; const k = a.cells[2]; const l = a.nodes; const m = l.length; const n = i.length; const o = a.tickID; if (a.numChannels === 2) { if (d = !0, m !== 0) { for (b = 0; m > b; ++b) { if (l[b].playbackState === e) { l[b].process(o), j.set(l[b].cells[1]), k.set(l[b].cells[2]), d = !1, ++b; break } } for (;m > b; ++b) { if (l[b].playbackState === e) { for (l[b].process(o), g = l[b].cells[1], h = l[b].cells[2], c = n; c;) { c -= 8, j[c] += g[c], k[c] += h[c], j[c + 1] += g[c + 1], k[c + 1] += h[c + 1], j[c + 2] += g[c + 2], k[c + 2] += h[c + 2], j[c + 3] += g[c + 3], k[c + 3] += h[c + 3], j[c + 4] += g[c + 4], k[c + 4] += h[c + 4], j[c + 5] += g[c + 5], k[c + 5] += h[c + 5], j[c + 6] += g[c + 6], k[c + 6] += h[c + 6], j[c + 7] += g[c + 7], k[c + 7] += h[c + 7] } } } }d && (j.set(t.emptycell), k.set(t.emptycell)) } else { if (d = !0, m !== 0) { for (b = 0; m > b; ++b) { if (l[b].playbackState === e) { l[b].process(o), i.set(l[b].cells[0]), d = !1, ++b; break } } for (;m > b; ++b) { if (l[b].playbackState === e) { for (f = l[b].process(o).cells[0], c = n; c;) { c -= 8, i[c] += f[c], i[c + 1] += f[c + 1], i[c + 2] += f[c + 2], i[c + 3] += f[c + 3], i[c + 4] += f[c + 4], i[c + 5] += f[c + 5], i[c + 6] += f[c + 6], i[c + 7] += f[c + 7] } } } }d && i.set(t.emptycell) } }, t.inputSignalKR = function (a) { let b; const c = a.nodes; const d = c.length; const f = a.tickID; let g = 0; for (b = 0; d > b; ++b) { c[b].playbackState === e && (g += c[b].process(f).cells[0][0]) } return g }, t.outputSignalAR = function (a) { let b; const c = a.cells[0]; const d = a.cells[1]; const e = a.cells[2]; const f = a._.mul; const g = a._.add; if (a.numChannels === 2) { for (b = c.length; b;) { b -= 8, d[b] = d[b] * f + g, e[b] = e[b] * f + g, d[b + 1] = d[b + 1] * f + g, e[b + 1] = e[b + 1] * f + g, d[b + 2] = d[b + 2] * f + g, e[b + 2] = e[b + 2] * f + g, d[b + 3] = d[b + 3] * f + g, e[b + 3] = e[b + 3] * f + g, d[b + 4] = d[b + 4] * f + g, e[b + 4] = e[b + 4] * f + g, d[b + 5] = d[b + 5] * f + g, e[b + 5] = e[b + 5] * f + g, d[b + 6] = d[b + 6] * f + g, e[b + 6] = e[b + 6] * f + g, d[b + 7] = d[b + 7] * f + g, e[b + 7] = e[b + 7] * f + g, c[b] = 0.5 * (d[b] + e[b]), c[b + 1] = 0.5 * (d[b + 1] + e[b + 1]), c[b + 2] = 0.5 * (d[b + 2] + e[b + 2]), c[b + 3] = 0.5 * (d[b + 3] + e[b + 3]), c[b + 4] = 0.5 * (d[b + 4] + e[b + 4]), c[b + 5] = 0.5 * (d[b + 5] + e[b + 5]), c[b + 6] = 0.5 * (d[b + 6] + e[b + 6]), c[b + 7] = 0.5 * (d[b + 7] + e[b + 7]) } } else if (f !== 1 || g !== 0) { for (b = c.length; b;) { b -= 8, c[b] = c[b] * f + g, c[b + 1] = c[b + 1] * f + g, c[b + 2] = c[b + 2] * f + g, c[b + 3] = c[b + 3] * f + g, c[b + 4] = c[b + 4] * f + g, c[b + 5] = c[b + 5] * f + g, c[b + 6] = c[b + 6] * f + g, c[b + 7] = c[b + 7] * f + g } } }, t.outputSignalKR = function (a) { let b; const c = a.cells[0]; const d = a.cells[1]; const e = a.cells[2]; const f = a._.mul; const g = a._.add; const h = c[0] * f + g; if (a.numChannels === 2) { for (b = c.length; b;) { b -= 8, c[b] = c[b + 1] = c[b + 2] = c[b + 3] = c[b + 4] = c[b + 5] = c[b + 6] = c[b + 7] = d[b] = d[b + 1] = d[b + 2] = d[b + 3] = d[b + 4] = d[b + 5] = d[b + 6] = d[b + 7] = e[b] = e[b + 1] = e[b + 2] = e[b + 3] = e[b + 4] = e[b + 5] = e[b + 6] = e[b + 7] = h } } else { for (b = c.length; b;) { b -= 8, c[b] = c[b + 1] = c[b + 2] = c[b + 3] = c[b + 4] = c[b + 5] = c[b + 6] = c[b + 7] = h } } }, t.buddies_start = function (a) { let b; let c; let d; const e = a._.buddies; for (c = 0, d = e.length; d > c; ++c) { switch (b = e[c], b.nodeType) { case A.DSP:b.play(); break; case A.TIMER:b.start(); break; case A.LISTENER:b.listen() } } }, t.buddies_stop = function (a) { let b; let c; let d; const e = a._.buddies; for (c = 0, d = e.length; d > c; ++c) { switch (b = e[c], b.nodeType) { case A.DSP:b.pause(); break; case A.TIMER:b.stop(); break; case A.LISTENER:b.unlisten() } } }, t.fix_iOS6_1_problem = function (a) { k.fix_iOS6_1_problem(a) }; let w; const x = b.modules = {}; const y = x.EventEmitter = (function () { function a (a) { this.context = a, this.events = {} } const b = a.prototype; return b.emit = function (a) { const b = this.events[a]; if (!b) { return !1 } let d; if (typeof b === 'function') { switch (arguments.length) { case 1:b.call(this.context); break; case 2:b.call(this.context, arguments[1]); break; case 3:b.call(this.context, arguments[1], arguments[2]); break; default:d = c.call(arguments, 1), b.apply(this.context, d) } return !0 } if (u(b)) { d = c.call(arguments, 1); for (let e = b.slice(), f = 0, g = e.length; g > f; ++f) { e[f] instanceof A ? e[f].bang.apply(e[f], d) : e[f].apply(this.context, d) } return !0 } return b instanceof A ? (d = c.call(arguments, 1), void b.bang.apply(b, d)) : !1 }, b.on = function (a, b) { if (typeof b !== 'function' && !(b instanceof A)) { throw new TypeError('addListener takes instances of Function or timbre.Object') } const c = this.events; return c[a] ? u(c[a]) ? c[a].push(b) : c[a] = [c[a], b] : c[a] = b, this }, b.once = function (a, b) { let c; const d = this; if (typeof b === 'function') { c = function () { d.off(a, c), b.apply(d.context, arguments) } } else { if (!(b instanceof A)) { throw new TypeError('once takes instances of Function or timbre.Object') } c = function () { d.off(a, c), b.bang.apply(b, arguments) } } return c.listener = b, d.on(a, c), this }, b.off = function (a, b) { if (typeof b !== 'function' && !(b instanceof A)) { throw new TypeError('removeListener takes instances of Function or timbre.Object') } const c = this.events; if (!c[a]) { return this } const d = c[a]; if (u(d)) { for (var e = -1, f = 0, g = d.length; g > f; ++f) { if (d[f] === b || d[f].listener && d[f].listener === b) { e = f; break } } if (e < 0) { return this } d.splice(e, 1), d.length === 0 && (c[a] = null) } else { (d === b || d.listener && d.listener === b) && (c[a] = null) } return this }, b.removeAllListeners = function (a) { const b = this.events; let c = !1; const d = b[a]; if (u(d)) { for (let e = d.length; e--;) { const f = d[e]; f.unremovable ? c = !0 : this.off(a, f) } } else { d && (d.unremovable ? c = !0 : this.off(a, d)) } return c || (b[a] = null), this }, b.listeners = function (a) { let b; let c = this.events; if (!c[a]) { return [] } if (c = c[a], !u(c)) { return c.unremovable ? [] : [c] } c = c.slice(), b = []; for (let d = 0, e = c.length; e > d; ++d) { c[d].unremovable || b.push(c[d]) } return b }, a }()); const z = x.Deferred = (function () { function a (a) { this.context = a || this, this._state = 'pending', this._doneList = [], this._failList = [], this._promise = new b(this) } function b (a) { this.context = a.context, this.then = a.then, this.done = function () { return a.done.apply(a, arguments), this }, this.fail = function () { return a.fail.apply(a, arguments), this }, this.pipe = function () { return a.pipe.apply(a, arguments) }, this.always = function () { return a.always.apply(a, arguments), this }, this.promise = function () { return this }, this.isResolved = function () { return a.isResolved() }, this.isRejected = function () { return a.isRejected() } } const d = a.prototype; const e = function (a, b, c, d) { if (this._state === 'pending') { this._state = a; for (let e = 0, f = b.length; f > e; ++e) { b[e].apply(c, d) } this._doneList = this._failList = null } }; const f = function (a) { return a && typeof a.promise === 'function' }; return d.resolve = function () { const a = c.call(arguments, 0); return e.call(this, 'resolved', this._doneList, this.context || this, a), this }, d.resolveWith = function (a) { const b = c.call(arguments, 1); return e.call(this, 'resolved', this._doneList, a, b), this }, d.reject = function () { const a = c.call(arguments, 0); return e.call(this, 'rejected', this._failList, this.context || this, a), this }, d.rejectWith = function (a) { const b = c.call(arguments, 1); return e.call(this, 'rejected', this._failList, a, b), this }, d.promise = function () { return this._promise }, d.done = function () { for (let a = c.call(arguments), b = this._state === 'resolved', d = this._state === 'pending', e = this._doneList, f = 0, g = a.length; g > f; ++f) { typeof a[f] === 'function' && (b ? a[f]() : d && e.push(a[f])) } return this }, d.fail = function () { for (let a = c.call(arguments), b = this._state === 'rejected', d = this._state === 'pending', e = this._failList, f = 0, g = a.length; g > f; ++f) { typeof a[f] === 'function' && (b ? a[f]() : d && e.push(a[f])) } return this }, d.always = function () { return this.done.apply(this, arguments), this.fail.apply(this, arguments), this }, d.then = function (a, b) { return this.done(a).fail(b) }, d.pipe = function (b, d) { const e = this; const g = new a(this.context); return this.done(function () { const a = b.apply(e.context, arguments); f(a) ? a.then(function () { const b = c.call(arguments); g.resolveWith.apply(g, [a].concat(b)) }) : g.resolveWith(e, a) }), this.fail(function () { if (typeof d === 'function') { const a = d.apply(e.context, arguments); f(a) && a.fail(function () { const b = c.call(arguments); g.rejectWith.apply(g, [a].concat(b)) }) } else { g.reject.apply(g, arguments) } }), g.promise() }, d.isResolved = function () { return this._state === 'resolved' }, d.isRejected = function () { return this._state === 'rejected' }, d.state = function () { return this._state }, a.when = function (b) { let d = 0; const e = c.call(arguments); const g = e.length; let h = g; g !== 1 || f(b) || (h = 0); const i = h === 1 ? b : new a(); const j = function (a, b) { return function (d) { b[a] = arguments.length > 1 ? c.call(arguments) : d, --h || i.resolve.apply(i, b) } }; if (g > 1) { for (let k = new Array(g), l = function () { i.reject() }; g > d; ++d) { e[d] && f(e[d]) ? e[d].promise().done(j(d, k)).fail(l) : (k[d] = e[d], --h) } } return h || i.resolve.apply(i, e), i.promise() }, a }()); var A = b.Object = (function () { function d (a, c) { this._ = {}; const f = this._.events = new y(this); if (this._.emit = function () { return f.emit.apply(f, arguments) }, v(c[0])) { const g = c.shift(); const h = g.in; this.once('init', function () { this.set(g), h && (u(h) ? this.append.apply(this, h) : h instanceof d && this.append(h)) }) } switch (this.tickID = -1, this.nodes = c.map(b), this.cells = [], this.numChannels = a, a) { case 0:this.L = this.R = new B(null), this.cells[0] = this.cells[1] = this.cells[2] = this.L.cell; break; case 1:this.L = this.R = new B(this), this.cells[0] = this.cells[1] = this.cells[2] = this.L.cell; break; case 2:this.L = new B(this), this.R = new B(this), this.cells[0] = new t.SignalArray(k.cellsize), this.cells[1] = this.L.cell, this.cells[2] = this.R.cell } this.playbackState = e, this.nodeType = d.DSP, this._.ar = !0, this._.mul = 1, this._.add = 0, this._.dac = null, this._.bypassed = !1, this._.meta = {}, this._.samplerate = k.samplerate, this._.cellsize = k.cellsize, this._.buddies = [] }d.DSP = 1, d.TIMER = 2, d.LISTENER = 3; const f = d.prototype; return Object.defineProperties(f, { isAr: { get () { return this._.ar } }, isKr: { get () { return !this._.ar } }, isBypassed: { get () { return this._.bypassed } }, isEnded: { get () { return !(1 & this.playbackState) } }, mul: { set (a) { typeof a === 'number' && (this._.mul = a, this._.emit('setMul', a)) }, get () { return this._.mul } }, add: { set (a) { typeof a === 'number' && (this._.add = a, this._.emit('setAdd', a)) }, get () { return this._.add } }, buddies: { set (a) { u(a) || (a = [a]), this._.buddies = a.filter(function (a) { return a instanceof d }) }, get () { return this._.buddies } } }), f.toString = function () { return this.constructor.name }, f.valueOf = function () { return k.tickID !== this.tickID && this.process(k.tickID), this.cells[0][0] }, f.append = function () { if (arguments.length > 0) { const a = c.call(arguments).map(b); this.nodes = this.nodes.concat(a), this._.emit('append', a) } return this }, f.appendTo = function (a) { return a.append(this), this }, f.remove = function () { if (arguments.length > 0) { for (var a, b = this.nodes, c = [], d = 0, e = arguments.length; e > d; ++d) { (a = b.indexOf(arguments[d])) !== -1 && (c.push(b[a]), b.splice(a, 1)) } c.length > 0 && this._.emit('remove', c) } return this }, f.removeFrom = function (a) { return a.remove(this), this }, f.removeAll = function () { const a = this.nodes.slice(); return this.nodes = [], a.length > 0 && this._.emit('remove', a), this }, f.removeAtIndex = function (a) { const b = this.nodes[a]; return b && (this.nodes.splice(a, 1), this._.emit('remove', [b])), this }, f.postMessage = function (a) { return this._.emit('message', a), this }, f.to = function (a) { if (a instanceof d) { a.append(this) } else { const b = c.call(arguments); v(b[1]) ? b.splice(2, 0, this) : b.splice(1, 0, this), a = r.apply(null, b) } return a }, f.splice = function (a, b, c) { let e; return b ? b instanceof d && (e = b.nodes.indexOf(c), e !== -1 && b.nodes.splice(e, 1), a instanceof d ? (a.nodes.push(this), b.nodes.push(a)) : b.nodes.push(this)) : this._.dac && (a instanceof d ? c instanceof d ? c._.dac && (c._.dac._.node = a, a._.dac = c._.dac, c._.dac = null, a.nodes.push(this)) : this._.dac && (this._.dac._.node = a, a._.dac = this._.dac, this._.dac = null, a.nodes.push(this)) : c instanceof d && c._.dac && (c._.dac._.node = this, this._.dac = c._.dac, c._.dac = null)), this }, f.on = f.addListener = function (a, b) { return this._.events.on(a, b), this }, f.once = function (a, b) { return this._.events.once(a, b), this }, f.off = f.removeListener = function (a, b) { return this._.events.off(a, b), this }, f.removeAllListeners = function (a) { return this._.events.removeAllListeners(a), this }, f.listeners = function (a) { return this._.events.listeners(a) }, f.set = function (a, b) { let c; let d; const e = this._.meta; switch (typeof a) { case 'string':switch (e[a]) { case 'property':this[a] = b; break; case 'function':this[a](b); break; default:for (c = this; c !== null;) { d = Object.getOwnPropertyDescriptor(c, a), d && (typeof d.value === 'function' ? (e[a] = 'function', this[a](b)) : (d.get || d.set) && (e[a] = 'property', this[a] = b)), c = Object.getPrototypeOf(c) } } break; case 'object':for (c in a) { this.set(c, a[c]) } } return this }, f.get = function (a) { return this._.meta[a] === 'property' ? this[a] : void 0 }, f.bang = function () { return this._.emit.apply(this, ['bang'].concat(c.call(arguments))), this }, f.process = t.nop, f.bypass = function () { return this._.bypassed = arguments.length === 0 ? !0 : !!arguments[0], this }, f.play = function () { let a = this._.dac; return a === null && (a = this._.dac = new I(this)), a.play() && this._.emit.apply(this, ['play'].concat(c.call(arguments))), t.buddies_start(this), this }, f.pause = function () { const a = this._.dac; return a && a.playbackState === e && (a.pause(), this._.dac = null, this._.emit('pause')), t.buddies_stop(this), this }, f.start = f.stop = f.listen = f.unlisten = function () { return this }, f.ar = function () { return (arguments.length === 0 ? 0 : !arguments[0]) ? this.kr(!0) : this._.kronly || (this._.ar = !0, this._.emit('ar', !0)), this }, f.kr = function () { return (arguments.length === 0 ? 0 : !arguments[0]) ? this.ar(!0) : this._.aronly || (this._.ar = !1, this._.emit('ar', !1)), this }, f.plot = n === 'browser' ? function (b) { const c = this._; const d = b.target; if (!d) { return this } let e; const f = b.width || d.width || 320; const g = b.height || d.height || 240; const h = (b.x || 0) + 0.5; const i = b.y || 0; const j = d.getContext('2d'); e = b.foreground !== a ? b.foreground : c.plotForeground || 'rgb(  0, 128, 255)'; let k; k = b.background !== a ? b.background : c.plotBackground || 'rgb(255, 255, 255)'; let l; let m; let n; let o; let p; const q = b.lineWidth || c.plotLineWidth || 1; const r = !!c.plotCyclic; const s = c.plotData || this.cells[0]; const t = b.range || c.plotRange || [-1.2, 1.2]; const u = t[0]; const v = g / (t[1] - u); const w = f / s.length; const x = s.length; if (j.save(), j.rect(h, i, f, g), k !== null && (j.fillStyle = k, j.fillRect(h, i, f, g)), c.plotBefore && c.plotBefore.call(this, j, h, i, f, g), c.plotBarStyle) { for (j.fillStyle = e, l = 0, p = 0; x > p; ++p) { n = (s[p] - u) * v, m = g - n, j.fillRect(l + h, m + i, w, n), l += w } } else { for (j.strokeStyle = e, j.lineWidth = q, j.beginPath(), l = 0, o = g - (s[0] - u) * v, j.moveTo(l + h, o + i), p = 1; x > p; ++p) { l += w, m = g - (s[p] - u) * v, j.lineTo(l + h, m + i) }r ? j.lineTo(l + w + h, o + i) : j.lineTo(l + w + h, m + i), j.stroke() }c.plotAfter && c.plotAfter.call(this, j, h, i, f, g); const y = b.border || c.plotBorder; return y && (j.strokeStyle = typeof y === 'string' ? y : '#000', j.lineWidth = 1, j.strokeRect(h, i, f, g)), j.restore(), this } : t.nop, d }()); var B = b.ChannelObject = (function () { function a (a) { b.Object.call(this, -1, []), t.fixAR(this), this._.parent = a, this.cell = new t.SignalArray(k.cellsize), this.L = this.R = this, this.cells[0] = this.cells[1] = this.cells[2] = this.cell, this.numChannels = 1 } return t.extend(a), a.prototype.process = function (a) { return this.tickID !== a && (this.tickID = a, this._.parent && this._.parent.process(a)), this }, a }()); var C = (function () { function a (a) { A.call(this, 2, a) } return t.extend(a), a.prototype.process = function (a) { const b = this._; return this.tickID !== a && (this.tickID = a, b.ar ? (t.inputSignalAR(this), t.outputSignalAR(this)) : (this.cells[0][0] = t.inputSignalKR(this), t.outputSignalKR(this))), this }, t.register('+', a), a }()); var D = (function () { function a (a) { if (A.call(this, 1, []), t.fixKR(this), this.value = a[0], v(a[1])) { const b = a[1]; this.once('init', function () { this.set(b) }) } this.on('setAdd', t.changeWithValue), this.on('setMul', t.changeWithValue) }t.extend(a); const b = a.prototype; return Object.defineProperties(b, { value: { set (a) { typeof a === 'number' && (this._.value = isNaN(a) ? 0 : a, t.changeWithValue.call(this)) }, get () { return this._.value } } }), a }()); var E = (function () { function a (a) { if (A.call(this, 1, []), t.fixKR(this), this.value = a[0], v(a[1])) { const b = a[1]; this.once('init', function () { this.set(b) }) } this.on('setAdd', t.changeWithValue), this.on('setMul', t.changeWithValue) }t.extend(a); const b = a.prototype; return Object.defineProperties(b, { value: { set (a) { this._.value = a ? 1 : 0, t.changeWithValue.call(this) }, get () { return !!this._.value } } }), a }()); var F = (function () { function a (a) { if (A.call(this, 1, []), t.fixKR(this), this.func = a[0], this._.value = 0, v(a[1])) { const b = a[1]; this.once('init', function () { this.set(b) }) } this.on('setAdd', t.changeWithValue), this.on('setMul', t.changeWithValue) }t.extend(a); const b = a.prototype; return Object.defineProperties(b, { func: { set (a) { typeof a === 'function' && (this._.func = a) }, get () { return this._.func } }, args: { set (a) { this._.args = u(a) ? a : [a] }, get () { return this._.args } } }), b.bang = function () { const a = this._; const b = c.call(arguments).concat(a.args); const d = a.func.apply(this, b); return typeof d === 'number' && (a.value = d, t.changeWithValue.call(this)), this._.emit('bang'), this }, a }()); var G = (function () { function a (a) { A.call(this, 1, []); let b, c; for (b = 0, c = a[0].length; c > b; ++b) { this.append(a[0][b]) } if (v(a[1])) { const d = a[1]; this.once('init', function () { this.set(d) }) } }t.extend(a); const b = a.prototype; return Object.defineProperties(b, {}), b.bang = function () { let a; let b; const d = ['bang'].concat(c.call(arguments)); const e = this.nodes; for (a = 0, b = e.length; b > a; ++a) { e[a].bang.apply(e[a], d) } return this }, b.postMessage = function (a) { let b; let c; const d = this.nodes; for (b = 0, c = d.length; c > b; ++b) { d[b].postMessage(a) } return this }, b.process = function (a) { const b = this._; return this.tickID !== a && (this.tickID = a, b.ar ? (t.inputSignalAR(this), t.outputSignalAR(this)) : (this.cells[0][0] = t.inputSignalKR(this), t.outputSignalKR(this))), this }, a }()); var H = (function () { function a (a) { if (A.call(this, 1, []), t.fixKR(this), v(a[1])) { const b = a[1]; this.once('init', function () { this.set(b) }) } }t.extend(a); const b = a.prototype; return Object.defineProperties(b, {}), a }()); var I = (function () { function a (a) { A.call(this, 2, []), this.playbackState = d; const e = this._; e.node = a, e.onplay = b(this), e.onpause = c(this) }t.extend(a); var b = function (a) { return function () { !k.inlets.includes(a) && (k.inlets.push(a), k.events.emit('addObject'), a.playbackState = e, a._.emit('play')) } }; var c = function (a) { return function () { const b = k.inlets.indexOf(a); b !== -1 && (k.inlets.splice(b, 1), a.playbackState = d, a._.emit('pause'), k.events.emit('removeObject')) } }; const f = a.prototype; return f.play = function () { return k.nextTick(this._.onplay), !k.inlets.includes(this) }, f.pause = function () { k.nextTick(this._.onpause) }, f.process = function (a) { const b = this._.node; 1 & b.playbackState ? (b.process(a), this.cells[1].set(b.cells[1]), this.cells[2].set(b.cells[2])) : (this.cells[1].set(t.emptycell), this.cells[2].set(t.emptycell)) }, a }()); const J = (function () { function a () { this.context = this, this.tickID = 0, this.impl = null, this.amp = 0.8, this.status = d, this.samplerate = 44100, this.channels = 2, this.cellsize = 64, this.streammsec = 20, this.streamsize = 0, this.currentTime = 0, this.nextTicks = [], this.inlets = [], this.timers = [], this.listeners = [], this.deferred = null, this.recStart = 0, this.recBuffers = null, this.delayProcess = b(this), this.events = null, t.currentTimeIncr = 1e3 * this.cellsize / this.samplerate, t.emptycell = new t.SignalArray(this.cellsize), this.reset(!0) } var b = function (a) { return function () { a.recStart = Date.now(), a.process() } }; const f = a.prototype; f.bind = function (a, b) { if (typeof a === 'function') { const c = new a(this, b); this.impl = c, this.impl.defaultSamplerate && (this.samplerate = this.impl.defaultSamplerate) } return this }, f.setup = function (a) { return typeof a === 'object' && (h.includes(a.samplerate) && (this.samplerate = a.samplerate <= this.impl.maxSamplerate ? a.samplerate : this.impl.maxSamplerate), i.includes(a.cellsize) && (this.cellsize = a.cellsize), typeof Float64Array !== 'undefined' && typeof a.f64 !== 'undefined' && (p = !!a.f64, t.SignalArray = p ? Float64Array : Float32Array)), t.currentTimeIncr = 1e3 * this.cellsize / this.samplerate, t.emptycell = new t.SignalArray(this.cellsize), this }, f.getAdjustSamples = function (a) { let b, c; return a = a || this.samplerate, b = this.streammsec / 1e3 * a, c = Math.ceil(Math.log(b) * Math.LOG2E), c = c < 8 ? 8 : c > 14 ? 14 : c, 1 << c }, f.play = function () { return this.status === d && (this.status = e, this.streamsize = this.getAdjustSamples(), this.strmL = new t.SignalArray(this.streamsize), this.strmR = new t.SignalArray(this.streamsize), this.impl.play(), this.events.emit('play')), this }, f.pause = function () { return this.status === e && (this.status = d, this.impl.pause(), this.events.emit('pause')), this }, f.reset = function (a) { return a && (this.events = new y(this).on('addObject', function () { this.status === d && this.play() }).on('removeObject', function () { this.status === e && this.inlets.length + this.timers.length + this.listeners.length === 0 && this.pause() })), this.currentTime = 0, this.nextTicks = [], this.inlets = [], this.timers = [], this.listeners = [], this }, f.process = function () { let a; let b; let c; let d; let e; let f; let h; let i; let j = this.tickID; const k = this.strmL; const l = this.strmR; const m = this.amp; let n = this.streamsize; let o = 0; const p = this.cellsize; let q = this.streamsize / this.cellsize; const r = this.timers; const s = this.inlets; const u = this.listeners; const v = t.currentTimeIncr; for (d = 0; n > d; ++d) { k[d] = l[d] = 0 } for (;q--;) { for (++j, e = 0, f = r.length; f > e; ++e) { 1 & r[e].playbackState && r[e].process(j) } for (e = 0, f = s.length; f > e; ++e) { if (a = s[e], a.process(j), 1 & a.playbackState) { for (b = a.cells[1], c = a.cells[2], h = 0, d = o; p > h; ++h, ++d) { k[d] += b[h], l[d] += c[h] } } } for (o += p, e = 0, f = u.length; f > e; ++e) { 1 & u[e].playbackState && u[e].process(j) } for (this.currentTime += v, i = this.nextTicks.splice(0), e = 0, f = i.length; f > e; ++e) { i[e]() } } for (d = 0; n > d; ++d) { a = k[d] * m, a < -1 ? a = -1 : a > 1 && (a = 1), k[d] = a, a = l[d] * m, a < -1 ? a = -1 : a > 1 && (a = 1), l[d] = a } this.tickID = j; const w = this.currentTime; if (this.status === g) { if (this.recCh === 2) { this.recBuffers.push(new t.SignalArray(k)), this.recBuffers.push(new t.SignalArray(l)) } else { const x = new t.SignalArray(k.length); for (d = 0, n = x.length; n > d; ++d) { x[d] = 0.5 * (k[d] + l[d]) } this.recBuffers.push(x) } if (w >= this.maxDuration) { this.deferred.sub.reject() } else if (w >= this.recDuration) { this.deferred.sub.resolve() } else { const y = Date.now(); y - this.recStart > 20 ? setTimeout(this.delayProcess, 10) : this.process() } } }, f.nextTick = function (a) { this.status === d ? a() : this.nextTicks.push(a) }, f.rec = function () { t.fix_iOS6_1_problem(!0); const a = new z(this); if (this.deferred) { return console.warn('rec deferred is exists??'), a.reject().promise() } if (this.status !== d) { return console.log('status is not none', this.status), a.reject().promise() } let b = 0; const e = arguments; const f = v(e[b]) ? e[b++] : {}; const h = e[b]; if (typeof h !== 'function') { return console.warn('no function'), a.reject().promise() } this.deferred = a, this.status = g, this.reset(); const i = new r('+'); const k = new z(this); const l = { done () { k.resolve.apply(k, c.call(arguments)) }, send () { i.append.apply(i, arguments) } }; const m = this; return k.then(j, function () { t.fix_iOS6_1_problem(!1), j.call(m, !0) }), this.deferred.sub = k, this.savedSamplerate = this.samplerate, this.samplerate = f.samplerate || this.samplerate, this.recDuration = f.recDuration || 1 / 0, this.maxDuration = f.maxDuration || 6e5, this.recCh = f.ch || 1, this.recCh !== 2 && (this.recCh = 1), this.recBuffers = [], this.streamsize = this.getAdjustSamples(), this.strmL = new t.SignalArray(this.streamsize), this.strmR = new t.SignalArray(this.streamsize), this.inlets.push(i), h(l), setTimeout(this.delayProcess, 10), a.promise() }; var j = function () { this.status = d, this.reset(); let a; const b = this.recBuffers; const c = this.samplerate; const e = this.streamsize; this.samplerate = this.savedSamplerate, a = 1 / 0 !== this.recDuration ? this.recDuration * c * 0.001 | 0 : (b.length >> this.recCh - 1) * e; let f; let g; let h = a / e | 0; let i = 0; let j = 0; let k = a; if (this.recCh === 2) { const l = new t.SignalArray(a); const m = new t.SignalArray(a); const n = new t.SignalArray(a); for (g = 0; h > g; ++g) { if (l.set(b[i++], j), m.set(b[i++], j), j += e, k -= e, k > 0 && e > k) { l.set(b[i++].subarray(0, k), j), m.set(b[i++].subarray(0, k), j); break } } for (g = 0, h = a; h > g; ++g) { n[g] = 0.5 * (l[g] + m[g]) }f = { samplerate: c, channels: 2, buffer: [n, l, m] } } else { const o = new t.SignalArray(a); for (g = 0; h > g; ++g) { if (o.set(b[i++], j), j += e, k -= e, k > 0 && e > k) { o.set(b[i++].subarray(0, k), j); break } }f = { samplerate: c, channels: 1, buffer: [o] } } const p = [].concat.apply([f], arguments); this.deferred.resolve.apply(this.deferred, p), this.deferred = null }; return f.on = function (a, b) { this.events.on(a, b) }, f.once = function (a, b) { this.events.once(a, b) }, f.off = function (a, b) { this.events.off(a, b) }, f.removeAllListeners = function (a) { this.events.removeListeners(a) }, f.listeners = function (a) { return this.events.listeners(a) }, f.fix_iOS6_1_problem = function (a) { this.impl.fix_iOS6_1_problem && this.impl.fix_iOS6_1_problem(a) }, a }()); let K = null; typeof window !== 'undefined' && (w = window.AudioContext || window.webkitAudioContext), K = typeof w !== 'undefined' ? function (a) { let b; let c; const d = new w(); t._audioContext = d, this.maxSamplerate = d.sampleRate, this.defaultSamplerate = d.sampleRate, this.env = 'webkit'; const e = navigator.userAgent; if (e.match(/linux/i) ? a.streammsec *= 8 : e.match(/win(dows)?\s*(nt 5\.1|xp)/i) && (a.streammsec *= 4), this.play = function () { let e; let f; let g; const h = a.getAdjustSamples(d.sampleRate); const i = a.streamsize; a.samplerate === d.sampleRate ? e = function (b) { const c = b.outputBuffer; a.process(), c.getChannelData(0).set(a.strmL), c.getChannelData(1).set(a.strmR) } : 2 * a.samplerate === d.sampleRate ? e = function (b) { let c; let d; const e = a.strmL; const f = a.strmR; const g = b.outputBuffer; const h = g.getChannelData(0); const i = g.getChannelData(1); const j = g.length; for (a.process(), c = d = 0; j > c; c += 2, ++d) { h[c] = h[c + 1] = e[d], i[c] = i[c + 1] = f[d] } } : (f = i, g = a.samplerate / d.sampleRate, e = function (b) { let c; const d = a.strmL; const e = a.strmR; const h = b.outputBuffer; const j = h.getChannelData(0); const k = h.getChannelData(1); const l = h.length; for (c = 0; l > c; ++c) { f >= i && (a.process(), f -= i), j[c] = d[0 | f], k[c] = e[0 | f], f += g } }), b = d.createBufferSource(), c = d.createScriptProcessor(h, 2, a.channels), c.onaudioprocess = e, b.noteOn && b.noteOn(0), b.connect(c), c.connect(d.destination) }, this.pause = function () { b.disconnect(), c.disconnect() }, o) { let f = 0; const g = d.createBufferSource(); this.fix_iOS6_1_problem = function (a) { f += a ? 1 : -1, f === 1 ? (g.noteOn(0), g.connect(d.destination)) : f === 0 && g.disconnect() } } } : function () { this.maxSamplerate = 48e3, this.defaultSamplerate = 44100, this.env = 'nop', this.play = function () {}, this.pause = function () {} }, k = (new J()).bind(K); const L = b; n === 'node' || typeof module !== 'undefined' && module.exports ? module.exports = global.timbre = L : n === 'browser' && (L.noConflict = (function () { const a = window.timbre; const b = window.T; return function (c) { return window.T === L && (window.T = b), c && window.timbre === L && (window.timbre = a), L } }()), window.timbre = window.T = L), (function () {
    function a (a) { try { return b.plugins && b.mimeTypes && b.mimeTypes.length ? b.plugins['Shockwave Flash'].description.match(/([0-9]+)/)[a] : new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').match(/([0-9]+)/)[a] } catch (c) { return -1 } } if (k.impl.env === 'nop' && n === 'browser' && !o) {
      var b = navigator; if (!(a(0) < 10)) {
        let c; const d = 'TimbreFlashPlayerDiv'; const e = (function () { const a = document.getElementsByTagName('script'); if (a && a.length) { for (var b, c = 0, d = a.length; d > c; ++c) { if (b = /^(.*\/)timbre(?:\.dev)?\.js$/i.exec(a[c].src)) { return b[1] + 'timbre.swf' } } } }()); window.timbrejs_flashfallback_init = function () { function a (a) { let b = 0; this.maxSamplerate = 44100, this.defaultSamplerate = 44100, this.env = 'flash', this.play = function () { let d; const f = new Array(a.streamsize * a.channels); const g = a.streammsec; let h = 0; const i = a.streamsize / a.samplerate * 1e3; const j = Date.now(); d = function () { if (!(h > Date.now() - j)) { const b = a.strmL; const d = a.strmR; let e = f.length; let g = b.length; for (a.process(); g--;) { f[--e] = 32768 * d[g] | 0, f[--e] = 32768 * b[g] | 0 }c.writeAudio(f.join(' ')), h += i } }, c.setup ? (c.setup(a.channels, a.samplerate), b = setInterval(d, g)) : console.warn('Cannot find ' + e) }, this.pause = function () { b !== 0 && (c.cancel(), clearInterval(b), b = 0) } }k.bind(a), delete window.timbrejs_flashfallback_init }; let f; let g; const h = e; const i = h + '?' + +new Date(); const j = 'TimbreFlashPlayer'; const l = document.createElement('div'); l.id = d, l.style.display = 'inline', l.width = l.height = 1, b.plugins && b.mimeTypes && b.mimeTypes.length ? (f = document.createElement('object'), f.id = j, f.classid = 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000', f.width = f.height = 1, f.setAttribute('data', i), f.setAttribute('type', 'application/x-shockwave-flash'), g = document.createElement('param'), g.setAttribute('name', 'allowScriptAccess'), g.setAttribute('value', 'always'), f.appendChild(g), l.appendChild(f)) : l.innerHTML = '<object id="' + j + '" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="1" height="1"><param name="movie" value="' + i + '" /><param name="bgcolor" value="#FFFFFF" /><param name="quality" value="high" /><param name="allowScriptAccess" value="always" /></object>', window.addEventListener('load', function () {
          document.body.appendChild(l), c = document[j]
        })
      }
    }
  }())
}()), (function (a) { 'use strict'; function b (a) { this.samplerate = a, this.frequency = 340, this.Q = 1, this.gain = 0, this.x1L = this.x2L = this.y1L = this.y2L = 0, this.x1R = this.x2R = this.y1R = this.y2R = 0, this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0, this.setType('lpf') } const c = b.prototype; c.process = function (a, b) { let c; let d; let e; let f; let g; let h; let i = this.x1L; let j = this.x2L; let k = this.y1L; let l = this.y2L; let m = this.x1R; let n = this.x2R; let o = this.y1R; let p = this.y2R; const q = this.b0; const r = this.b1; const s = this.b2; const t = this.a1; const u = this.a2; for (g = 0, h = a.length; h > g; ++g) { c = a[g], e = q * c + r * i + s * j - t * k - u * l, j = i, i = c, l = k, k = e, d = b[g], f = q * d + r * m + s * n - t * o - u * p, n = m, m = d, p = o, o = f, a[g] = e, b[g] = f } this.x1L = i, this.x2L = j, this.y1L = k, this.y2L = l, this.x1R = m, this.x2R = n, this.y1R = o, this.y2R = p }, c.setType = function (a) { let b; (b = d[a]) && (this.type = a, b.call(this, this.frequency, this.Q, this.gain)) }, c.setParams = function (a, b, c) { this.frequency = a, this.Q = b, this.gain = c; const e = d[this.type]; return e && e.call(this, a, b, c), this }; var d = { lowpass (a, b) { if (a /= 0.5 * this.samplerate, a >= 1) { this.b0 = 1, this.b1 = this.b2 = this.a1 = this.a2 = 0 } else if (a <= 0) { this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0 } else { b = b < 0 ? 0 : b; const c = 10 ** (0.05 * b); const d = Math.sqrt(0.5 * (4 - Math.sqrt(16 - 16 / (c * c)))); const e = Math.PI * a; const f = 0.5 * d * Math.sin(e); const g = 0.5 * (1 - f) / (1 + f); const h = (0.5 + g) * Math.cos(e); const i = 0.25 * (0.5 + g - h); this.b0 = 2 * i, this.b1 = 4 * i, this.b2 = this.b0, this.a1 = 2 * -h, this.a2 = 2 * g } }, highpass (a, b) { if (a /= 0.5 * this.samplerate, a >= 1) { this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0 } else if (a <= 0) { this.b0 = 1, this.b1 = this.b2 = this.a1 = this.a2 = 0 } else { b = b < 0 ? 0 : b; const c = 10 ** (0.05 * b); const d = Math.sqrt((4 - Math.sqrt(16 - 16 / (c * c))) / 2); const e = Math.PI * a; const f = 0.5 * d * Math.sin(e); const g = 0.5 * (1 - f) / (1 + f); const h = (0.5 + g) * Math.cos(e); const i = 0.25 * (0.5 + g + h); this.b0 = 2 * i, this.b1 = -4 * i, this.b2 = this.b0, this.a1 = 2 * -h, this.a2 = 2 * g } }, bandpass (a, b) { if (a /= 0.5 * this.samplerate, a > 0 && a < 1) { if (b > 0) { const c = Math.PI * a; const d = Math.sin(c) / (2 * b); const e = Math.cos(c); const f = 1 / (1 + d); this.b0 = d * f, this.b1 = 0, this.b2 = -d * f, this.a1 = -2 * e * f, this.a2 = (1 - d) * f } else { this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0 } } else { this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0 } }, lowshelf (a, b, c) { a /= 0.5 * this.samplerate; const d = 10 ** (c / 40); if (a >= 1) { this.b0 = d * d, this.b1 = this.b2 = this.a1 = this.a2 = 0 } else if (a <= 0) { this.b0 = 1, this.b1 = this.b2 = this.a1 = this.a2 = 0 } else { const e = Math.PI * a; const f = 1; const g = 0.5 * Math.sin(e) * Math.sqrt((d + 1 / d) * (1 / f - 1) + 2); const h = Math.cos(e); const i = 2 * Math.sqrt(d) * g; const j = d + 1; const k = d - 1; const l = 1 / (j + k * h + i); this.b0 = d * (j - k * h + i) * l, this.b1 = 2 * d * (k - j * h) * l, this.b2 = d * (j - k * h - i) * l, this.a1 = -2 * (k + j * h) * l, this.a2 = (j + k * h - i) * l } }, highshelf (a, b, c) { a /= 0.5 * this.samplerate; const d = 10 ** (c / 40); if (a >= 1) { this.b0 = 1, this.b1 = this.b2 = this.a1 = this.a2 = 0 } else if (a <= 0) { this.b0 = d * d, this.b1 = this.b2 = this.a1 = this.a2 = 0 } else { const e = Math.PI * a; const f = 1; const g = 0.5 * Math.sin(e) * Math.sqrt((d + 1 / d) * (1 / f - 1) + 2); const h = Math.cos(e); const i = 2 * Math.sqrt(d) * g; const j = d + 1; const k = d - 1; const l = 1 / (j - k * h + i); this.b0 = d * (j + k * h + i) * l, this.b1 = -2 * d * (k + j * h) * l, this.b2 = d * (j + k * h - i) * l, this.a1 = 2 * (k - j * h) * l, this.a2 = (j - k * h - i) * l } }, peaking (a, b, c) { if (a /= 0.5 * this.samplerate, a > 0 && a < 1) { const d = 10 ** (c / 40); if (b > 0) { const e = Math.PI * a; const f = Math.sin(e) / (2 * b); const g = Math.cos(e); const h = 1 / (1 + f / d); this.b0 = (1 + f * d) * h, this.b1 = -2 * g * h, this.b2 = (1 - f * d) * h, this.a1 = this.b1, this.a2 = (1 - f / d) * h } else { this.b0 = d * d, this.b1 = this.b2 = this.a1 = this.a2 = 0 } } else { this.b0 = 1, this.b1 = this.b2 = this.a1 = this.a2 = 0 } }, notch (a, b) { if (a /= 0.5 * this.samplerate, a > 0 && a < 1) { if (b > 0) { const c = Math.PI * a; const d = Math.sin(c) / (2 * b); const e = Math.cos(c); const f = 1 / (1 + d); this.b0 = f, this.b1 = -2 * e * f, this.b2 = f, this.a1 = this.b1, this.a2 = (1 - d) * f } else { this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0 } } else { this.b0 = 1, this.b1 = this.b2 = this.a1 = this.a2 = 0 } }, allpass (a, b) { if (a /= 0.5 * this.samplerate, a > 0 && a < 1) { if (b > 0) { const c = Math.PI * a; const d = Math.sin(c) / (2 * b); const e = Math.cos(c); const f = 1 / (1 + d); this.b0 = (1 - d) * f, this.b1 = -2 * e * f, this.b2 = (1 + d) * f, this.a1 = this.b1, this.a2 = this.b0 } else { this.b0 = -1, this.b1 = this.b2 = this.a1 = this.a2 = 0 } } else { this.b0 = 1, this.b1 = this.b2 = this.a1 = this.a2 = 0 } } }; d.lpf = d.lowpass, d.hpf = d.highpass, d.bpf = d.bandpass, d.bef = d.notch, d.brf = d.notch, d.apf = d.allpass, a.modules.Biquad = b }(timbre)), (function (a) { 'use strict'; function b (b) { this.samplerate = b; const c = Math.round(Math.log(0.1 * b) * Math.LOG2E); this.buffersize = 1 << c, this.bufferL = new a.fn.SignalArray(this.buffersize + 1), this.bufferR = new a.fn.SignalArray(this.buffersize + 1), this.wave = null, this._wave = null, this.writeIndex = this.buffersize >> 1, this.readIndex = 0, this.delayTime = 20, this.rate = 4, this.depth = 20, this.feedback = 0.2, this.wet = 0.5, this.phase = 0, this.phaseIncr = 0, this.phaseStep = 4, this.setWaveType('sin'), this.setDelayTime(this.delayTime), this.setRate(this.rate) } const c = b.prototype; const d = []; d[0] = (function () { for (var a = new Float32Array(512), b = 0; b < 512; ++b) { a[b] = Math.sin(2 * Math.PI * (b / 512)) } return a }()), d[1] = (function () { for (var a, b = new Float32Array(512), c = 0; c < 512; ++c) { a = c / 512 - 0.25, b[c] = 1 - 4 * Math.abs(Math.round(a) - a) } return b }()), c.setWaveType = function (a) { a === 'sin' ? (this.wave = a, this._wave = d[0]) : a === 'tri' && (this.wave = a, this._wave = d[1]) }, c.setDelayTime = function (a) { this.delayTime = a; for (var b = this.writeIndex - (a * this.samplerate * 0.001 | 0); b < 0;) { b += this.buffersize } this.readIndex = b }, c.setRate = function (a) { this.rate = a, this.phaseIncr = 512 * this.rate / this.samplerate * this.phaseStep }, c.process = function (a, b) { let c; let d; let e; let f; let g; const h = this.bufferL; const i = this.bufferR; const j = this.buffersize; const k = j - 1; const l = this._wave; let m = this.phase; const n = this.phaseIncr; let o = this.writeIndex; let p = this.readIndex; const q = this.depth; const r = this.feedback; const s = this.wet; const t = 1 - s; const u = a.length; const v = this.phaseStep; for (f = 0; u > f;) { for (e = l[0 | m] * q, m += n; m > 512;) { m -= 512 } for (g = 0; v > g; ++g, ++f) { d = p + j + e & k, c = 0.5 * (h[d] + h[d + 1]), h[o] = a[f] - c * r, a[f] = a[f] * t + c * s, c = 0.5 * (i[d] + i[d + 1]), i[o] = b[f] - c * r, b[f] = b[f] * t + c * s, o = o + 1 & k, p = p + 1 & k } } this.phase = m, this.writeIndex = o, this.readIndex = p }, a.modules.Chorus = b }(timbre)), (function (a) { 'use strict'; function b (b, d) { this.samplerate = b, this.channels = d, this.lastPreDelayFrames = 0, this.preDelayReadIndex = 0, this.preDelayWriteIndex = e, this.ratio = -1, this.slope = -1, this.linearThreshold = -1, this.dbThreshold = -1, this.dbKnee = -1, this.kneeThreshold = -1, this.kneeThresholdDb = -1, this.ykneeThresholdDb = -1, this.K = -1, this.attackTime = 0.003, this.releaseTime = 0.25, this.preDelayTime = 0.006, this.dbPostGain = 0, this.effectBlend = 1, this.releaseZone1 = 0.09, this.releaseZone2 = 0.16, this.releaseZone3 = 0.42, this.releaseZone4 = 0.98, this.detectorAverage = 0, this.compressorGain = 1, this.meteringGain = 1, this.delayBufferL = new a.fn.SignalArray(c), this.delayBufferR = d === 2 ? new a.fn.SignalArray(c) : this.delayBufferL, this.preDelayTime = 6, this.preDelayReadIndex = 0, this.preDelayWriteIndex = e, this.maxAttackCompressionDiffDb = -1, this.meteringReleaseK = 1 - Math.exp(-1 / (0.325 * this.samplerate)), this.setAttackTime(this.attackTime), this.setReleaseTime(this.releaseTime), this.setPreDelayTime(this.preDelayTime), this.setParams(-24, 30, 12) } var c = 1024; const d = c - 1; var e = 256; const f = 5; const g = b.prototype; g.clone = function () { const a = new b(this.samplerate, this.channels); return a.setAttackTime(this.attackTime), a.setReleaseTime(this.releaseTime), a.setPreDelayTime(this.preDelayTime), a.setParams(this.dbThreshold, this.dbKnee, this.ratio), a }, g.setAttackTime = function (a) { this.attackTime = Math.max(0.001, a), this._attackFrames = this.attackTime * this.samplerate }, g.setReleaseTime = function (a) { this.releaseTime = Math.max(0.001, a); const b = this.releaseTime * this.samplerate; const c = 0.0025; this._satReleaseFrames = c * this.samplerate; const d = b * this.releaseZone1; const e = b * this.releaseZone2; const f = b * this.releaseZone3; const g = b * this.releaseZone4; this._kA = 0.9999999999999998 * d + 1.8432219684323923e-16 * e - 1.9373394351676423e-16 * f + 8.824516011816245e-18 * g, this._kB = -1.5788320352845888 * d + 2.3305837032074286 * e - 0.9141194204840429 * f + 0.1623677525612032 * g, this._kC = 0.5334142869106424 * d - 1.272736789213631 * e + 0.9258856042207512 * f - 0.18656310191776226 * g, this._kD = 0.08783463138207234 * d - 0.1694162967925622 * e + 0.08588057951595272 * f - 0.00429891410546283 * g, this._kE = -0.042416883008123074 * d + 0.1115693827987602 * e - 0.09764676325265872 * f + 0.028494263462021576 * g }, g.setPreDelayTime = function (a) { this.preDelayTime = a; let b = a * this.samplerate; if (b > c - 1 && (b = c - 1), this.lastPreDelayFrames !== b) { this.lastPreDelayFrames = b; for (let d = 0, e = this.delayBufferL.length; e > d; ++d) { this.delayBufferL[d] = this.delayBufferR[d] = 0 } this.preDelayReadIndex = 0, this.preDelayWriteIndex = b } }, g.setParams = function (a, b, c) { this._k = this.updateStaticCurveParameters(a, b, c); const d = this.saturate(1, this._k); let e = 1 / d; e = e ** 0.6, this._masterLinearGain = 10 ** (0.05 * this.dbPostGain) * e }, g.kneeCurve = function (a, b) { return a < this.linearThreshold ? a : this.linearThreshold + (1 - Math.exp(-b * (a - this.linearThreshold))) / b }, g.saturate = function (a, b) { let c; if (a < this.kneeThreshold) { c = this.kneeCurve(a, b) } else { const d = a ? 20 * Math.log(a) * Math.LOG10E : -1e3; const e = this.ykneeThresholdDb + this.slope * (d - this.kneeThresholdDb); c = 10 ** (0.05 * e) } return c }, g.slopeAt = function (a, b) { if (a < this.linearThreshold) { return 1 } const c = 1.001 * a; const d = a ? 20 * Math.log(a) * Math.LOG10E : -1e3; const e = c ? 20 * Math.log(c) * Math.LOG10E : -1e3; const f = this.kneeCurve(a, b); const g = this.kneeCurve(c, b); const h = f ? 20 * Math.log(f) * Math.LOG10E : -1e3; const i = g ? 20 * Math.log(g) * Math.LOG10E : -1e3; return (i - h) / (e - d) }, g.kAtSlope = function (a) { for (var b = this.dbThreshold + this.dbKnee, c = 10 ** (0.05 * b), d = 0.1, e = 1e4, f = 5, g = 0; g < 15; ++g) { const h = this.slopeAt(c, f); a > h ? e = f : d = f, f = Math.sqrt(d * e) } return f }, g.updateStaticCurveParameters = function (a, b, c) { this.dbThreshold = a, this.linearThreshold = 10 ** (0.05 * a), this.dbKnee = b, this.ratio = c, this.slope = 1 / this.ratio, this.kneeThresholdDb = a + b, this.kneeThreshold = 10 ** (0.05 * this.kneeThresholdDb); const d = this.kAtSlope(1 / this.ratio); const e = this.kneeCurve(this.kneeThreshold, d); return this.ykneeThresholdDb = e ? 20 * Math.log(e) * Math.LOG10E : -1e3, this._k = d, this._k }, g.process = function (a, b) { for (var c = 1 - this.effectBlend, e = this.effectBlend, g = this._k, h = this._masterLinearGain, i = this._satReleaseFrames, j = this._kA, k = this._kB, l = this._kC, m = this._kD, n = this._kE, o = 64, p = a.length / o, q = 0, r = this.detectorAverage, s = this.compressorGain, t = this.maxAttackCompressionDiffDb, u = 1 / this._attackFrames, v = this.preDelayReadIndex, w = this.preDelayWriteIndex, x = this.detectorAverage, y = this.delayBufferL, z = this.delayBufferR, A = this.meteringGain, B = this.meteringReleaseK, C = 0; p > C; ++C) { var D; const E = Math.asin(r) / (0.5 * Math.PI); const F = E > s; let G = s / E; let H = G ? 20 * Math.log(G) * Math.LOG10E : -1e3; if ((1 / 0 === H || isNaN(H)) && (H = -1), F) { t = -1, G = H, G = G < -12 ? 0 : G > 0 ? 3 : 0.25 * (G + 12); const I = G * G; const J = I * G; const K = I * I; const L = j + k * G + l * I + m * J + n * K; const M = f / L; D = 10 ** (0.05 * M) } else { (t === -1 || H > t) && (t = H); const N = Math.max(0.5, t); G = 0.25 / N, D = 1 - G ** u } for (let O = o; O--;) { let P = 0; let Q = 0.5 * (a[q] + b[q]); y[w] = a[q], z[w] = b[q], Q < 0 && (Q *= -1), Q > P && (P = Q); let R = P; R < 0 && (R *= -1); const S = this.saturate(R, g); const T = R <= 1e-4 ? 1 : S / R; let U = T ? -20 * Math.log(T) * Math.LOG10E : 1e3; U < 2 && (U = 2); const V = U / i; const W = 10 ** (0.05 * V) - 1; const X = T > x; const Y = X ? W : 1; x += (T - x) * Y, x > 1 && (x = 1), D < 1 ? s += (E - s) * D : (s *= D, s > 1 && (s = 1)); const Z = Math.sin(0.5 * Math.PI * s); const $ = c + e * h * Z; const _ = 20 * Math.log(Z) * Math.LOG10E; A > _ ? A = _ : A += (_ - A) * B, a[q] = y[v] * $, b[q] = z[v] * $, q++, v = v + 1 & d, w = w + 1 & d }x < 1e-6 && (x = 1e-6), s < 1e-6 && (s = 1e-6) } this.preDelayReadIndex = v, this.preDelayWriteIndex = w, this.detectorAverage = x, this.compressorGain = s, this.maxAttackCompressionDiffDb = t, this.meteringGain = A }, g.reset = function () { this.detectorAverage = 0, this.compressorGain = 1, this.meteringGain = 1; for (let a = 0, b = this.delayBufferL.length; b > a; ++a) { this.delayBufferL[a] = this.delayBufferR[a] = 0 } this.preDelayReadIndex = 0, this.preDelayWriteIndex = e, this.maxAttackCompressionDiffDb = -1 }, a.modules.Compressor = b }(timbre)), (function (a) { 'use strict'; function b () {}b.prototype.decode = function (a, c, d) { if (typeof a === 'string') { if (/\.wav$/.test(a)) { return b.wav_decode(a, c, d) } if (b.ogg_decode && /\.ogg$/.test(a)) { return b.ogg_decode(a, c, d) } if (b.mp3_decode && /\.mp3$/.test(a)) { return b.mp3_decode(a, c, d) } } else if (typeof a === 'object') { if (a.type === 'wav') { return b.wav_decode(a.data, c, d) } if (b.ogg_decode && a.type === 'ogg') { return b.ogg_decode(a.data, c, d) } if (b.mp3_decode && a.type === 'mp3') { return b.mp3_decode(a.data, c, d) } } return b.webkit_decode ? typeof a === 'object' ? b.webkit_decode(a.data || a, c, d) : b.webkit_decode(a, c, d) : b.moz_decode ? b.moz_decode(a, c, d) : void c(!1) }, a.modules.Decoder = b, b.getBinaryWithPath = a.envtype === 'browser' ? function (b, c) { a.fn.fix_iOS6_1_problem(!0); const d = new XMLHttpRequest(); d.open('GET', b), d.responseType = 'arraybuffer', d.onreadystatechange = function () { d.readyState === 4 && (d.response ? c(new Uint8Array(d.response)) : void 0 !== d.responseBody && c(new Uint8Array(VBArray(d.responseBody).toArray())), a.fn.fix_iOS6_1_problem(!1)) }, d.send() } : function (a, b) { b('no support') }; const c = function (a) { for (var b, c, d, e, f, g = new Int32Array(a.length / 3), h = 0, i = a.length, j = 0; i > h;) { b = a[h++], c = a[h++], d = a[h++], e = b + (c << 8) + (d << 16), f = 8388608 & e ? e - 16777216 : e, g[j++] = f } return g }; b.wav_decode = (function () { const a = function (a, b, d) { if (String.fromCharCode(a[0], a[1], a[2], a[3]) !== 'RIFF') { return b(!1) } const e = a[4] + (a[5] << 8) + (a[6] << 16) + (a[7] << 24); if (e + 8 !== a.length) { return b(!1) } if (String.fromCharCode(a[8], a[9], a[10], a[11]) !== 'WAVE') { return b(!1) } if (String.fromCharCode(a[12], a[13], a[14], a[15]) !== 'fmt ') { return b(!1) } for (var f = a[22] + (a[23] << 8), g = a[24] + (a[25] << 8) + (a[26] << 16) + (a[27] << 24), h = a[34] + (a[35] << 8), i = 36; i < a.length && String.fromCharCode(a[i], a[i + 1], a[i + 2], a[i + 3]) !== 'data';) { i += 1 } if (i >= a.length) { return b(!1) } i += 4; const j = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24); const k = (j / f >> 1) / g; if (i += 4, j > a.length - i) { return b(!1) } let l, m, n; l = new Float32Array(k * g | 0), f === 2 && (m = new Float32Array(l.length), n = new Float32Array(l.length)), b({ samplerate: g, channels: f, buffer: [l, m, n], duration: k }), h === 8 ? a = new Int8Array(a.buffer, i) : h === 16 ? a = new Int16Array(a.buffer, i) : h === 32 ? a = new Int32Array(a.buffer, i) : h === 24 && (a = c(new Uint8Array(a.buffer, i))); let o; let p; let q; const r = 1 / ((1 << h - 1) - 1); if (f === 2) { for (i = p = 0, o = l.length; o > i; ++i) { q = m[i] = a[p++] * r, q += n[i] = a[p++] * r, l[i] = 0.5 * q } } else { for (i = 0, o = l.length; o > i; ++i) { l[i] = a[i] * r } }d() }; return function (c, d, e) { typeof c === 'string' ? b.getBinaryWithPath(c, function (b) { a(b, d, e) }) : a(c, d, e) } }()), b.webkit_decode = (function () { if (typeof a.fn._audioContext !== 'undefined') { const c = a.fn._audioContext; const d = function (a, b, d) { let e, f, g, h, i; if (typeof a === 'string') { return d(!1) } let j; try { j = c.createBuffer(a.buffer, !1) } catch (k) { return b(!1) }e = c.sampleRate, f = j.numberOfChannels, f === 2 ? (g = j.getChannelData(0), h = j.getChannelData(1)) : g = h = j.getChannelData(0), i = g.length / e; for (var l = new Float32Array(g), m = 0, n = l.length; n > m; ++m) { l[m] = 0.5 * (l[m] + h[m]) }b({ samplerate: e, channels: f, buffer: [l, g, h], duration: i }), d() }; return function (a, c, e) { if (a instanceof File) { const f = new FileReader(); f.onload = function (a) { d(new Uint8Array(a.target.result), c, e) }, f.readAsArrayBuffer(a) } else { typeof a === 'string' ? b.getBinaryWithPath(a, function (a) { d(a, c, e) }) : d(a, c, e) } } } }()), b.moz_decode = (function () { return typeof Audio === 'function' && typeof (new Audio()).mozSetup === 'function' ? function (a, b, c) { let d; let e; let f; let g; let h; let i; let j = 0; const k = new Audio(a); k.volume = 0, k.addEventListener('loadedmetadata', function () { d = k.mozSampleRate, e = k.mozChannels, i = k.duration, f = new Float32Array(k.duration * d | 0), e === 2 && (g = new Float32Array(k.duration * d | 0), h = new Float32Array(k.duration * d | 0)), e === 2 ? k.addEventListener('MozAudioAvailable', function (a) { for (var b, c = a.frameBuffer, d = 0, e = c.length; e > d; d += 2) { b = g[j] = c[d], b += h[j] = c[d + 1], f[j] = 0.5 * b, j += 1 } }, !1) : k.addEventListener('MozAudioAvailable', function (a) { for (let b = a.frameBuffer, c = 0, d = b.length; d > c; ++c) { f[c] = b[c], j += 1 } }, !1), k.play(), setTimeout(function () { b({ samplerate: d, channels: e, buffer: [f, g, h], duration: i }) }, 1e3) }, !1), k.addEventListener('ended', function () { c() }, !1), k.load() } : void 0 }()) }(timbre)), (function (a) { 'use strict'; function b (a) { this.samplerate = a || 44100, this.value = d, this.status = m, this.curve = 'linear', this.step = 1, this.releaseNode = null, this.loopNode = null, this.emit = null, this._envValue = new c(a), this._table = [], this._initValue = d, this._curveValue = 0, this._defaultCurveType = f, this._index = 0, this._counter = 0 } function c (a) { this.samplerate = a, this.value = d, this.step = 1, this._curveType = f, this._curveValue = 0, this._grow = 0, this._a2 = 0, this._b1 = 0, this._y1 = 0, this._y2 = 0 } var d = b.ZERO = 1e-6; const e = b.CurveTypeSet = 0; var f = b.CurveTypeLin = 1; const g = b.CurveTypeExp = 2; const h = b.CurveTypeSin = 3; const i = b.CurveTypeWel = 4; const j = b.CurveTypeCurve = 5; const k = b.CurveTypeSqr = 6; const l = b.CurveTypeCub = 7; var m = b.StatusWait = 0; const n = b.StatusGate = 1; const o = b.StatusSustain = 2; const p = b.StatusRelease = 3; const q = b.StatusEnd = 4; const r = { set: e, lin: f, linear: f, exp: g, exponential: g, sin: h, sine: h, wel: i, welch: i, sqr: k, squared: k, cub: l, cubed: l }; b.CurveTypeDict = r; const s = b.prototype; s.clone = function () { const a = new b(this.samplerate); return a._table = this._table, a._initValue = this._initValue, a.setCurve(this.curve), this.releaseNode !== null && a.setReleaseNode(this.releaseNode + 1), this.loopNode !== null && a.setLoopNode(this.loopNode + 1), a.setStep(this.step), a.reset(), a }, s.setTable = function (a) { this._initValue = a[0], this._table = a.slice(1), this.value = this._envValue.value = this._initValue, this._index = 0, this._counter = 0, this.status = m }, s.setCurve = function (a) { typeof a === 'number' ? (this._defaultCurveType = j, this._curveValue = a, this.curve = a) : (this._defaultCurveType = r[a] || null, this.curve = a) }, s.setReleaseNode = function (a) { typeof a === 'number' && a > 0 && (this.releaseNode = a - 1) }, s.setLoopNode = function (a) { typeof a === 'number' && a > 0 && (this.loopNode = a - 1) }, s.setStep = function (a) { this.step = this._envValue.step = a }, s.reset = function () { this.value = this._envValue.value = this._initValue, this._index = 0, this._counter = 0, this.status = m }, s.release = function () { this.releaseNode !== null && this._index <= this.releaseNode && (this._counter = 0, this._index = this.releaseNode, this.status = p) }, s.getInfo = function (a) { let b; let c; const d = this._table; let e = 0; let f = 1 / 0; let g = 1 / 0; let h = !1; for (b = 0, c = d.length; c > b; ++b) { this.loopNode === b && (f = e), this.releaseNode === b && (a > e ? e += a : e = a, g = e); const i = d[b]; Array.isArray(i) && (e += i[1]) } return 1 / 0 !== f && 1 / 0 === g && (e += a, h = !0), { totalDuration: e, loopBeginTime: f, releaseBeginTime: g, isEndlessLoop: h } }, s.calcStatus = function () { let a; let b; let c; let d; let g = this.status; const h = this._table; let i = this._index; let k = this._counter; let l = this._curveValue; const r = this._defaultCurveType; const s = this.loopNode; const t = this.releaseNode; const u = this._envValue; let v = null; switch (g) { case m:case q:break; case n:case p:for (;k <= 0;) { if (i >= h.length) { if (g === n && s !== null) { i = s; continue }g = q, k = 1 / 0, d = e, v = 'ended' } else if (g !== n || i !== t) { a = h[i++], b = a[0], d = a[2] === null ? r : a[2], d === j && (l = a[3], Math.abs(l) < 0.001 && (d = f)), c = a[1], k = u.setNext(b, c, d, l) } else { if (s !== null && t > s) { i = s; continue }g = o, k = 1 / 0, d = e, v = 'sustained' } } } return this.status = g, this.emit = v, this._index = i, this._counter = k, g }, s.next = function () { return 1 & this.calcStatus() && (this.value = this._envValue.next() || d), this._counter -= 1, this.value }, s.process = function (a) { let b; const c = this._envValue; const e = a.length; if (1 & this.calcStatus()) { for (b = 0; e > b; ++b) { a[b] = c.next() || d } } else { const f = this.value || d; for (b = 0; e > b; ++b) { a[b] = f } } this.value = a[e - 1], this._counter -= a.length }, c.prototype.setNext = function (a, b, c, d) { let m; let n; let o; let p; let q; let r; let s; const u = this.step; let v = this.value; let w = 0.001 * b * this.samplerate / u | 0; switch (w < 1 && (w = 1, c = e), c) { case e:this.value = a; break; case f:m = (a - v) / w; break; case g:m = v !== 0 ? (a / v) ** (1 / w) : 0; break; case h:n = Math.PI / w, p = 0.5 * (a + v), q = 2 * Math.cos(n), r = 0.5 * (a - v), s = r * Math.sin(0.5 * Math.PI - n), v = p - r; break; case i:n = 0.5 * Math.PI / w, q = 2 * Math.cos(n), a >= v ? (p = v, r = 0, s = -Math.sin(n) * (a - v)) : (p = a, r = v - a, s = Math.cos(n) * (v - a)), v = p + r; break; case j:o = (a - v) / (1 - Math.exp(d)), p = v + o, q = o, m = Math.exp(d / w); break; case k:r = Math.sqrt(v), s = Math.sqrt(a), m = (s - r) / w; break; case l:r = v ** 0.33333333, s = a ** 0.33333333, m = (s - r) / w } return this.next = t[c], this._grow = m, this._a2 = p, this._b1 = q, this._y1 = r, this._y2 = s, w }; var t = []; t[e] = function () { return this.value }, t[f] = function () { return this.value += this._grow, this.value }, t[g] = function () { return this.value *= this._grow, this.value }, t[h] = function () { const a = this._b1 * this._y1 - this._y2; return this.value = this._a2 - a, this._y2 = this._y1, this._y1 = a, this.value }, t[i] = function () { const a = this._b1 * this._y1 - this._y2; return this.value = this._a2 + a, this._y2 = this._y1, this._y1 = a, this.value }, t[j] = function () { return this._b1 *= this._grow, this.value = this._a2 - this._b1, this.value }, t[k] = function () { return this._y1 += this._grow, this.value = this._y1 * this._y1, this.value }, t[l] = function () { return this._y1 += this._grow, this.value = this._y1 * this._y1 * this._y1, this.value }, c.prototype.next = t[e], a.modules.Envelope = b, a.modules.EnvelopeValue = c }(timbre)), (function (a) { 'use strict'; function b (b) { b = typeof b === 'number' ? b : 512, b = 1 << Math.ceil(Math.log(b) * Math.LOG2E), this.length = b, this.buffer = new a.fn.SignalArray(b), this.real = new a.fn.SignalArray(b), this.imag = new a.fn.SignalArray(b), this._real = new a.fn.SignalArray(b), this._imag = new a.fn.SignalArray(b), this.mag = new a.fn.SignalArray(b >> 1), this.minDecibels = -30, this.maxDecibels = -100; const c = d.get(b); this._bitrev = c.bitrev, this._sintable = c.sintable, this._costable = c.costable } const c = b.prototype; c.setWindow = function (b) { if (typeof b === 'string') { const c = /([A-Za-z]+)(?:\(([01]\.?\d*)\))?/.exec(b); if (c !== null) { const d = c[1].toLowerCase(); let f = void 0 !== c[2] ? +c[2] : 0.25; const g = e[d]; if (g) { this._window || (this._window = new a.fn.SignalArray(this.length)); const h = this._window; let i = 0; const j = this.length; for (f = f < 0 ? 0 : f > 1 ? 1 : f; j > i; ++i) { h[i] = g(i, j, f) } this.windowName = b } } } }, c.forward = function (a) { let b; let c; let d; let e; let f; let g; let h; let i; let j; let k; let l; const m = this.buffer; const n = this.real; const o = this.imag; const p = this._window; const q = this._bitrev; const r = this._sintable; const s = this._costable; const t = m.length; if (p) { for (b = 0; t > b; ++b) { m[b] = a[b] * p[b] } } else { m.set(a) } for (b = 0; t > b; ++b) { n[b] = m[q[b]], o[b] = 0 } for (d = 1; t > d; d = e) { for (f = 0, e = d + d, g = t / e, c = 0; d > c; c++) { for (h = s[f], i = r[f], b = c; t > b; b += e) { j = b + d, k = i * o[j] + h * n[j], l = h * o[j] - i * n[j], n[j] = n[b] - k, n[b] += k, o[j] = o[b] - l, o[b] += l }f += g } } let u; let v; const w = this.mag; for (b = 0; t > b; ++b) { u = n[b], v = o[b], w[b] = Math.sqrt(u * u + v * v) } return { real: n, imag: o } }, c.inverse = function (a, b) { let c; let d; let e; let f; let g; let h; let i; let j; let k; let l; let m; const n = this.buffer; const o = this._real; const p = this._imag; const q = this._bitrev; const r = this._sintable; const s = this._costable; const t = n.length; for (c = 0; t > c; ++c) { d = q[c], o[c] = +a[d], p[c] = -b[d] } for (e = 1; t > e; e = f) { for (g = 0, f = e + e, h = t / f, d = 0; e > d; d++) { for (i = s[g], j = r[g], c = d; t > c; c += f) { k = c + e, l = j * p[k] + i * o[k], m = i * p[k] - j * o[k], o[k] = o[c] - l, o[c] += l, p[k] = p[c] - m, p[c] += m }g += h } } for (c = 0; t > c; ++c) { n[c] = o[c] / t } return n }, c.getFrequencyData = function (a) { let b; const c = this.minDecibels; const d = Math.min(this.mag.length, a.length); if (d) { let e; const f = this.mag; let g = 0; for (b = 0; d > b; ++b) { e = f[b], a[b] = e ? 20 * Math.log(e) * Math.LOG10E : c, g < a[b] && (g = a[b]) } } return a }; var d = { get (b) { return d[b] || (function () { let c; let e; const f = (function () { let a, c, d, e, f; for (a = new Int16Array(b), f = b >> 1, c = d = 0; a[c] = d, !(++c >= b);) { for (e = f; d >= e;) { d -= e, e >>= 1 }d += e } return a }()); const g = Math.floor(Math.log(b) / Math.LN2); const h = new a.fn.SignalArray((1 << g) - 1); const i = new a.fn.SignalArray((1 << g) - 1); const j = 2 * Math.PI; for (c = 0, e = h.length; e > c; ++c) { h[c] = Math.sin(j * (c / b)), i[c] = Math.cos(j * (c / b)) } return d[b] = { bitrev: f, sintable: h, costable: i }, d[b] }()) } }; var e = (function () { const a = Math.PI; const b = 2 * Math.PI; const c = Math.abs; const d = Math.pow; const e = Math.cos; const f = Math.sin; const g = function (b) { return f(a * b) / (a * b) }; const h = Math.E; return { rectangular () { return 1 }, hann (a, c) { return 0.5 * (1 - e(b * a / (c - 1))) }, hamming (a, c) { return 0.54 - 0.46 * e(b * a / (c - 1)) }, tukery (b, c, d) { return d * (c - 1) / 2 > b ? 0.5 * (1 + e(a * (2 * b / (d * (c - 1)) - 1))) : b > (c - 1) * (1 - d / 2) ? 0.5 * (1 + e(a * (2 * b / (d * (c - 1)) - 2 / d + 1))) : 1 }, cosine (b, c) { return f(a * b / (c - 1)) }, lanczos (a, b) { return g(2 * a / (b - 1) - 1) }, triangular (a, b) { return 2 / (b + 1) * ((b + 1) / 2 - c(a - (b - 1) / 2)) }, bartlett (a, b) { return 2 / (b - 1) * ((b - 1) / 2 - c(a - (b - 1) / 2)) }, gaussian (a, b, c) { return d(h, -0.5 * d((a - (b - 1) / 2) / (c * (b - 1) / 2), 2)) }, bartlettHann (a, d) { return 0.62 - 0.48 * c(a / (d - 1) - 0.5) - 0.38 * e(b * a / (d - 1)) }, blackman (c, d, f) { const g = (1 - f) / 2; const h = 0.5; const i = f / 2; return g - h * e(b * c / (d - 1)) + i * e(4 * a * c / (d - 1)) } } }()); a.modules.FFT = b }(timbre)), (function (a) { 'use strict'; function b (a) { this.samplerate = a || 44100, this.wave = null, this.step = 1, this.frequency = 0, this.value = 0, this.phase = 0, this.feedback = !1, this._x = 0, this._lastouts = 0, this._coeff = f / this.samplerate, this._radtoinc = f / (2 * Math.PI) } function c (a, b, c, d) { let e; let f; let g; let h; let i; let j = k[b]; if (void 0 !== j) { switch (typeof j === 'function' && (j = j()), c) { case '@1':for (f = 512; f < 1024; ++f) { j[f] = 0 } break; case '@2':for (f = 512; f < 1024; ++f) { j[f] = Math.abs(j[f]) } break; case '@3':for (f = 256; f < 512; ++f) { j[f] = 0 } for (f = 512; f < 768; ++f) { j[f] = Math.abs(j[f]) } for (f = 768; f < 1024; ++f) { j[f] = 0 } break; case '@4':for (e = new Float32Array(1024), f = 0; f < 512; ++f) { e[f] = j[f << 1] }j = e; break; case '@5':for (e = new Float32Array(1024), f = 0; f < 512; ++f) { e[f] = Math.abs(j[f << 1]) }j = e } if (void 0 !== d && d !== 50) { for (d *= 0.01, d = d < 0 ? 0 : d > 1 ? 1 : d, e = new Float32Array(1024), g = 1024 * d | 0, f = 0; g > f; ++f) { e[f] = j[f / g * 512 | 0] } for (i = 1024 - g, h = 0; f < 1024; ++f, ++h) { e[f] = j[h / i * 512 + 512 | 0] }j = e } if (a === '+') { for (f = 0; f < 1024; ++f) { j[f] = 0.5 * j[f] + 0.5 } } else if (a === '-') { for (f = 0; f < 1024; ++f) { j[f] *= -1 } } return j } } function d (a) { const b = new Float32Array(1024); const c = a.length >> 1; if ([2, 4, 8, 16, 32, 64, 128, 256, 512, 1024].includes(c)) { for (let d = 0, e = 0; c > d; ++d) { let f = parseInt(a.substr(2 * d, 2), 16); f = 128 & f ? (f - 256) / 128 : f / 127; for (let g = 0, h = 1024 / c; h > g; ++g) { b[e++] = f } } } return b } function e (a) { const b = new Float32Array(1024); if (a.length === 8) { let c; let d; let e = parseInt(a, 16); const f = new Float32Array(8); for (f[0] = 1, c = 0; c < 7; ++c) { f[c + 1] = 0.0625 * (15 & e), e >>= 4 } for (c = 0; c < 8; ++c) { let g = 0; const h = (c + 1) / 1024; for (d = 0; d < 1024; ++d) { b[d] += Math.sin(2 * Math.PI * g) * f[c], g += h } } let i; let j = 0; for (c = 0; c < 1024; ++c) { j < (i = Math.abs(b[c])) && (j = i) } if (j > 0) { for (c = 0; c < 1024; ++c) { b[c] /= j } } } return b } var f = 1024; const g = f - 1; const h = b.prototype; h.setWave = function (b) { let c; let d; const e = this.wave; if (this.wave || (this.wave = new Float32Array(f + 1)), typeof b === 'function') { for (c = 0; f > c; ++c) { e[c] = b(c / f) } } else if (a.fn.isSignalArray(b)) { if (b.length === e.length) { e.set(b) } else { for (d = b.length / f, c = 0; f > c; ++c) { e[c] = b[c * d | 0] } } } else { typeof b === 'string' && void 0 !== (d = i(b)) && this.wave.set(d) } this.wave[f] = this.wave[0] }, h.clone = function () { const a = new b(this.samplerate); return a.wave = this.wave, a.step = this.step, a.frequency = this.frequency, a.value = this.value, a.phase = this.phase, a.feedback = this.feedback, a }, h.reset = function () { this._x = 0 }, h.next = function () { let a = this._x; const b = a + this.phase * this._radtoinc | 0; return this.value = this.wave[b & g], a += this.frequency * this._coeff * this.step, a > f && (a -= f), this._x = a, this.value }, h.process = function (a) { let b; let c; let d; let e; let h; let i; const j = this.wave; let k = this._radtoinc; let l = this._x; const m = this.frequency * this._coeff; const n = this.step; if (this.feedback) { let o = this._lastouts; for (k *= this.phase, i = 0; n > i; ++i) { b = l + o * k, c = 0 | b, d = b - c, c &= g, e = j[c], h = j[c + 1], a[i] = o = e + d * (h - e), l += m } this._lastouts = o } else { const p = this.phase * k; for (i = 0; n > i; ++i) { b = l + p, c = 0 | b, d = b - c, c &= g, e = j[c], h = j[c + 1], a[i] = e + d * (h - e), l += m } }l > f && (l -= f), this._x = l, this.value = a[a.length - 1] }, h.processWithFreqArray = function (a, b) { let c; let d; let e; let h; let i; let j; const k = this.wave; let l = this._radtoinc; let m = this._x; const n = this._coeff; const o = this.step; if (this.feedback) { let p = this._lastouts; for (l *= this.phase, j = 0; o > j; ++j) { c = m + p * l, d = 0 | c, e = c - d, d &= g, h = k[d], i = k[d + 1], a[j] = p = h + e * (i - h), m += b[j] * n } this._lastouts = p } else { const q = this.phase * this._radtoinc; for (j = 0; o > j; ++j) { c = m + q, d = 0 | c, e = c - d, d &= g, h = k[d], i = k[d + 1], a[j] = h + e * (i - h), m += b[j] * n } }m > f && (m -= f), this._x = m, this.value = a[a.length - 1] }, h.processWithPhaseArray = function (a, b) { let c; let d; let e; let h; let i; let j; const k = this.wave; let l = this._radtoinc; let m = this._x; const n = this.frequency * this._coeff; const o = this.step; if (this.feedback) { let p = this._lastouts; for (l *= this.phase, j = 0; o > j; ++j) { c = m + p * l, d = 0 | c, e = c - d, d &= g, h = k[d], i = k[d + 1], a[j] = p = h + e * (i - h), m += n } this._lastouts = p } else { for (j = 0; o > j; ++j) { c = m + b[j] * l, d = 0 | c, e = c - d, d &= g, h = k[d], i = k[d + 1], a[j] = h + e * (i - h), m += n } }m > f && (m -= f), this._x = m, this.value = a[a.length - 1] }, h.processWithFreqAndPhaseArray = function (a, b, c) { let d; let e; let h; let i; let j; let k; const l = this.wave; let m = this._radtoinc; let n = this._x; const o = this._coeff; const p = this.step; if (this.feedback) { let q = this._lastouts; for (m *= this.phase, k = 0; p > k; ++k) { d = n + q * m, e = 0 | d, h = d - e, e &= g, i = l[e], j = l[e + 1], a[k] = q = i + h * (j - i), n += b[k] * o } this._lastouts = q } else { for (k = 0; p > k; ++k) { d = n + c[k] * f, e = 0 | d, h = d - e, e &= g, i = l[e], j = l[e + 1], a[k] = i + h * (j - i), n += b[k] * o } }n > f && (n -= f), this._x = n, this.value = a[a.length - 1] }; var i = function (a) { let b = k[a]; if (void 0 !== b) { return typeof b === 'function' && (b = b()), b } let f; if (f = /^([\-+]?)(\w+)(?:\((@[0-7])?:?(\d+)?\))?$/.exec(a), f !== null) { const g = f[1]; const h = f[2]; const i = f[3]; const j = f[4]; if (b = c(g, h, i, j), void 0 !== b) { return k[a] = b, b } } return f = /^wavb\(((?:[0-9a-fA-F][0-9a-fA-F])+)\)$/.exec(a), f !== null ? d(f[1]) : (f = /^wavc\(([0-9a-fA-F]{8})\)$/.exec(a), f !== null ? e(f[1]) : void 0) }; b.getWavetable = i; const j = function (b, c) { let d; let e; const f = new Float32Array(1024); if (typeof c === 'function') { for (e = 0; e < 1024; ++e) { f[e] = c(e / 1024) } } else if (a.fn.isSignalArray(c)) { if (c.length === f.length) { f.set(c) } else { for (d = c.length / 1024, e = 0; e < 1024; ++e) { f[e] = c[e * d | 0] } } }k[b] = f }; b.setWavetable = j; var k = { sin () { for (var a = new Float32Array(1024), b = 0; b < 1024; ++b) { a[b] = Math.sin(2 * Math.PI * (b / 1024)) } return a }, cos () { for (var a = new Float32Array(1024), b = 0; b < 1024; ++b) { a[b] = Math.cos(2 * Math.PI * (b / 1024)) } return a }, pulse () { for (var a = new Float32Array(1024), b = 0; b < 1024; ++b) { a[b] = b < 512 ? 1 : -1 } return a }, tri () { for (var a, b = new Float32Array(1024), c = 0; c < 1024; ++c) { a = c / 1024 - 0.25, b[c] = 1 - 4 * Math.abs(Math.round(a) - a) } return b }, saw () { for (var a, b = new Float32Array(1024), c = 0; c < 1024; ++c) { a = c / 1024, b[c] = 2 * (a - Math.round(a)) } return b }, fami () { for (var a = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 0.875, 0.75, 0.625, 0.5, 0.375, 0.25, 0.125, 0, -0.125, -0.25, -0.375, -0.5, -0.625, -0.75, -0.875, -1, -1, -0.875, -0.75, -0.625, -0.5, -0.375, -0.25, -0.125], b = new Float32Array(1024), c = 0; c < 1024; ++c) { b[c] = a[c / 1024 * a.length | 0] } return b }, konami () { for (var a = [-0.625, -0.875, -0.125, 0.75, 0.5, 0.125, 0.5, 0.75, 0.25, -0.125, 0.5, 0.875, 0.625, 0, 0.25, 0.375, -0.125, -0.75, 0, 0.625, 0.125, -0.5, -0.375, -0.125, -0.75, -1, -0.625, 0, -0.375, -0.875, -0.625, -0.25], b = new Float32Array(1024), c = 0; c < 1024; ++c) { b[c] = a[c / 1024 * a.length | 0] } return b } }; a.modules.Oscillator = b }(timbre)), (function (a) { 'use strict'; function b (b, g) { this.samplerate = b; let h; let i; const j = b / 44100; for (i = 2 * e.length, this.comb = new Array(i), this.combout = new Array(i), h = 0; i > h; ++h) { this.comb[h] = new c(e[h % e.length] * j), this.combout[h] = new a.fn.SignalArray(g) } for (i = 2 * f.length, this.allpass = new Array(i), h = 0; i > h; ++h) { this.allpass[h] = new d(f[h % f.length] * j) } this.outputs = [new a.fn.SignalArray(g), new a.fn.SignalArray(g)], this.damp = 0, this.wet = 0.33, this.setRoomSize(0.5), this.setDamp(0.5) } function c (b) { this.buffer = new a.fn.SignalArray(0 | b), this.buffersize = this.buffer.length, this.bufidx = 0, this.feedback = 0, this.filterstore = 0, this.damp = 0 } function d (b) { this.buffer = new a.fn.SignalArray(0 | b), this.buffersize = this.buffer.length, this.bufidx = 0 } var e = [1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617]; var f = [225, 556, 441, 341]; const g = b.prototype; g.setRoomSize = function (a) { const b = this.comb; const c = 0.28 * a + 0.7; this.roomsize = a, b[0].feedback = b[1].feedback = b[2].feedback = b[3].feedback = b[4].feedback = b[5].feedback = b[6].feedback = b[7].feedback = b[8].feedback = b[9].feedback = b[10].feedback = b[11].feedback = b[12].feedback = b[13].feedback = b[14].feedback = b[15].feedback = c }, g.setDamp = function (a) { const b = this.comb; const c = 0.4 * a; this.damp = a, b[0].damp = b[1].damp = b[2].damp = b[3].damp = b[4].damp = b[5].damp = b[6].damp = b[7].damp = b[8].damp = b[9].damp = b[10].damp = b[11].damp = b[12].damp = b[13].damp = b[14].damp = b[15].damp = c }, g.process = function (a, b) { let c; const d = this.comb; const e = this.combout; const f = this.allpass; const g = this.outputs[0]; const h = this.outputs[1]; const i = this.wet; const j = 1 - i; const k = a.length; for (d[0].process(a, e[0]), d[1].process(a, e[1]), d[2].process(a, e[2]), d[3].process(a, e[3]), d[4].process(a, e[4]), d[5].process(a, e[5]), d[6].process(a, e[6]), d[7].process(a, e[7]), d[8].process(b, e[8]), d[9].process(b, e[9]), d[10].process(b, e[10]), d[11].process(b, e[11]), d[12].process(b, e[12]), d[13].process(b, e[13]), d[14].process(b, e[14]), d[15].process(b, e[15]), c = 0; k > c; ++c) { g[c] = e[0][c] + e[1][c] + e[2][c] + e[3][c] + e[4][c] + e[5][c] + e[6][c] + e[7][c], h[c] = e[8][c] + e[9][c] + e[10][c] + e[11][c] + e[12][c] + e[13][c] + e[14][c] + e[15][c] } for (f[0].process(g, g), f[1].process(g, g), f[2].process(g, g), f[3].process(g, g), f[4].process(h, h), f[5].process(h, h), f[6].process(h, h), f[7].process(h, h), c = 0; k > c; ++c) { a[c] = g[c] * i + a[c] * j, b[c] = h[c] * i + b[c] * j } }, c.prototype.process = function (a, b) { let c; let d; let e; const f = this.buffer; const g = this.buffersize; let h = this.bufidx; let i = this.filterstore; const j = this.feedback; const k = this.damp; const l = 1 - k; const m = a.length; for (e = 0; m > e; ++e) { c = 0.015 * a[e], d = f[h], i = d * l + i * k, f[h] = c + i * j, ++h >= g && (h = 0), b[e] = d } this.bufidx = h, this.filterstore = i }, d.prototype.process = function (a, b) { let c; let d; let e; let f; const g = this.buffer; const h = this.buffersize; let i = this.bufidx; const j = a.length; for (f = 0; j > f; ++f) { c = a[f], e = g[i], d = -c + e, g[i] = c + 0.5 * e, ++i >= h && (i = 0), b[f] = d } this.bufidx = i }, a.modules.Reverb = b }(timbre)), (function (a) {
  'use strict'; function b (a) { return new c(a) } function c (a) { if (this.fragments = [], a) { const b = a.samplerate || 44100; const c = a.buffer[0].length / b; this.fragments.push(new d(a, 0, c)) } } function d (a, b, c, d, e, f, h) { a || (a = g), this.buffer = a.buffer[0], this.samplerate = a.samplerate || 44100, this.start = b, this._duration = c, this.reverse = d || !1, this.pitch = e || 100, this.stretch = f || !1, this.pan = h || 50 } function e (a, b) { this.tape = a, this.fragments = a.fragments, this.samplerate = b || 44100, this.isEnded = !1, this.buffer = null, this.bufferIndex = 0, this.bufferIndexIncr = 0, this.bufferBeginIndex = 0, this.bufferEndIndex = 0, this.fragment = null, this.fragmentIndex = 0, this.panL = 0.5, this.panR = 0.5 } const f = new Float32Array(60); var g = { buffer: f, samplerate: 1 }; b.silence = function (a) { return new b(g).slice(0, 1).fill(a) }, b.join = function (a) { for (var b = new c(), d = 0; d < a.length; d++) { a[d] instanceof c && b.add_fragments(a[d].fragments) } return b }, b.Tape = c, c.prototype.add_fragment = function (a) { return this.fragments.push(a), this }, c.prototype.add_fragments = function (a) { for (let b = 0; b < a.length; b++) { this.fragments.push(a[b]) } return this }, c.prototype.duration = function () {
    for (var a = 0, b = 0; b < this.fragments.length; b++) { a += this.fragments[b].duration() }
    return a
  }, c.prototype.slice = function (a, b) { const d = this.duration(); a + b > d && (b = d - a); for (var e = new c(), f = a, g = b, h = 0; h < this.fragments.length; h++) { const i = this.fragments[h]; const j = i.create(f, g); const k = j[0]; if (f = j[1], g = j[2], k && e.add_fragment(k), g === 0) { break } } return e }, c.prototype.cut = c.prototype.slice, c.prototype.concat = function (a) { const b = new c(); return b.add_fragments(this.fragments), b.add_fragments(a.fragments), b }, c.prototype.loop = function (a) { let b; const d = []; for (b = 0; b < this.fragments.length; b++) { d.push(this.fragments[b].clone()) } const e = new c(); for (b = 0; a > b; b++) { e.add_fragments(d) } return e }, c.prototype.times = c.prototype.loop, c.prototype.split = function (a) { for (var b = this.duration() / a, c = [], d = 0; a > d; d++) { c.push(this.slice(d * b, b)) } return c }, c.prototype.fill = function (a) { const b = this.duration(); if (b === 0) { throw 'EmptyFragment' } const c = a / b | 0; const d = a % b; return this.loop(c).plus(this.slice(0, d)) }, c.prototype.replace = function (a, d, e) { let f = new c(); const g = a + d; f = f.plus(this.slice(0, a)); const h = f.duration(); a > h && (f = f.plus(b.silence(a - h))), f = f.plus(e); const i = this.duration(); return i > g && (f = f.plus(this.slice(g, i - g))), f }, c.prototype.reverse = function () { for (var a = new c(), b = this.fragments.length; b--;) { const d = this.fragments[b].clone(); d.reverse = !d.isReversed(), a.add_fragment(d) } return a }, c.prototype.pitch = function (a, b) { const d = new c(); b = b || !1; for (let e = 0; e < this.fragments.length; e++) { const f = this.fragments[e].clone(); f.pitch *= 0.01 * a, f.stretch = b, d.add_fragment(f) } return d }, c.prototype.stretch = function (a) { const b = 1 / (0.01 * a) * 100; return this.pitch(b, !0) }, c.prototype.pan = function (a) { const b = new c(); a > 100 ? a = 100 : a < 0 && (a = 0); for (let d = 0; d < this.fragments.length; d++) { const e = this.fragments[d].clone(); e.pan = a, b.add_fragment(e) } return b }, c.prototype.silence = function () { return b.silence(this.duration()) }, c.prototype.join = function (a) { for (var b = new c(), d = 0; d < a.length; d++) { a[d] instanceof c && b.add_fragments(a[d].fragments) } return b }, c.prototype.getBuffer = function () { let a = 44100; this.fragments.length > 0 && (a = this.fragments[0].samplerate); const b = new e(this, a); const c = this.duration() * a | 0; return { samplerate: a, buffer: b.fetch(c) } }, d.prototype.duration = function () { return this._duration * (100 / this.pitch) }, d.prototype.original_duration = function () { return this._duration }, d.prototype.isReversed = function () { return this.reverse }, d.prototype.isStretched = function () { return this.stretched }, d.prototype.create = function (a, b) { const c = this.duration(); if (a >= c) { return [null, a - c, b] } let d; const e = a + b >= c; e ? (d = c - a, b -= d) : (d = b, b = 0); const f = this.clone(); return f.start = this.start + a * this.pitch * 0.01, f._duration = d * this.pitch * 0.01, f.reverse = !1, [f, 0, b] }, d.prototype.clone = function () { const a = new d(); return a.buffer = this.buffer, a.samplerate = this.samplerate, a.start = this.start, a._duration = this._duration, a.reverse = this.reverse, a.pitch = this.pitch, a.stretch = this.stretch, a.pan = this.pan, a }, b.Fragment = d, b.TapeStream = e, e.prototype.reset = function () { return this.isEnded = !1, this.buffer = null, this.bufferIndex = 0, this.bufferIndexIncr = 0, this.bufferBeginIndex = 0, this.bufferEndIndex = 0, this.fragment = null, this.fragmentIndex = 0, this.panL = 0.5, this.panR = 0.5, this.isLooped = !1, this }, e.prototype.fetch = function (b) { const c = new a.fn.SignalArray(b); const d = new a.fn.SignalArray(b); const e = this.fragments; if (e.length === 0) { return [c, d] } for (var g, h = 100 * this.samplerate, i = this.buffer, j = this.bufferIndex, k = this.bufferIndexIncr, l = this.bufferBeginIndex, m = this.bufferEndIndex, n = this.fragment, o = this.fragmentIndex, p = this.panL, q = this.panR, r = 0; b > r; r++) { for (;!i || l > j || j >= m;) { if (!n || o < e.length) { n = e[o++], i = n.buffer, k = n.samplerate / h * n.pitch, l = n.start * n.samplerate, m = l + n.original_duration() * n.samplerate, g = 0.01 * n.pan, p = 1 - g, q = g, n.reverse ? (k *= -1, j = m + k) : j = l } else { if (!this.isLooped) { this.isEnded = !0, i = f, k = 0, j = 0; break }i = null, j = 0, k = 0, l = 0, m = 0, n = null, o = 0 } }c[r] = i[0 | j] * p, d[r] = i[0 | j] * q, j += k } return this.buffer = i, this.bufferIndex = j, this.bufferIndexIncr = k, this.bufferBeginIndex = l, this.bufferEndIndex = m, this.fragment = n, this.fragmentIndex = o, this.panL = p, this.panR = q, [c, d] }, a.modules.Scissor = b
}(timbre)), (function (a) { 'use strict'; function b (b) { this.samplerate = b; const c = Math.ceil(Math.log(1.5 * b) * Math.LOG2E); this.buffersize = 1 << c, this.buffermask = this.buffersize - 1, this.writeBufferL = new a.fn.SignalArray(this.buffersize), this.writeBufferR = new a.fn.SignalArray(this.buffersize), this.readBufferL = this.writeBufferL, this.readBufferR = this.writeBufferR, this.delaytime = null, this.feedback = null, this.cross = null, this.mix = null, this.prevL = 0, this.prevR = 0, this.readIndex = 0, this.writeIndex = 0, this.setParams(125, 0.25, !1, 0.45) } const c = b.prototype; c.setParams = function (a, b, c, d) { if (this.delaytime !== a) { this.delaytime = a; let e = 0.001 * a * this.samplerate | 0; e > this.buffermask && (e = this.buffermask), this.writeIndex = this.readIndex + e & this.buffermask } this.feedback !== b && (this.feedback = b), this.cross !== c && (this.cross = c, c ? (this.readBufferL = this.writeBufferR, this.readBufferR = this.writeBufferL) : (this.readBufferL = this.writeBufferL, this.readBufferR = this.writeBufferR)), this.mix !== d && (this.mix = d) }, c.process = function (a, b) { let c; let d; const e = this.readBufferL; const f = this.readBufferR; const g = this.writeBufferL; const h = this.writeBufferR; let i = this.readIndex; let j = this.writeIndex; const k = this.buffermask; const l = this.feedback; const m = this.mix; const n = 1 - m; let o = this.prevL; let p = this.prevR; const q = a.length; for (d = 0; q > d; ++d) { c = e[i], g[j] = a[d] - c * l, a[d] = o = 0.5 * (a[d] * n + c * m + o), c = f[i], h[j] = b[d] - c * l, b[d] = p = 0.5 * (b[d] * n + c * m + p), i += 1, j = j + 1 & k } this.readIndex = i & this.buffermask, this.writeIndex = j, this.prevL = o, this.prevR = p }, a.modules.StereoDelay = b }(timbre)), (function (a) { 'use strict'; const b = a.fn; const c = a.modules; b.register('audio', function (a) { const c = b.getClass('buffer'); const f = new c(a); return f.playbackState = b.FINISHED_STATE, f._.isLoaded = !1, Object.defineProperties(f, { isLoaded: { get () { return this._.isLoaded } } }), f.load = d, f.loadthis = e, f }); var d = function (d) { const e = this; const f = this._; const g = new c.Deferred(this); const h = arguments; let i = 1; g.done(function () { e._.emit('done') }), typeof h[i] === 'function' && (g.done(h[i++]), typeof h[i] === 'function' && g.fail(h[i++])), f.loadedTime = 0; const j = function (c, d) { const f = e._; c ? (e.playbackState = b.PLAYING_STATE, f.samplerate = c.samplerate, f.channels = c.channels, f.bufferMix = null, f.buffer = c.buffer, f.phase = 0, f.phaseIncr = c.samplerate / a.samplerate, f.duration = 1e3 * c.duration, f.currentTime = 0, f.isReversed && (f.phaseIncr *= -1, f.phase = c.buffer[0].length + f.phaseIncr), e._.emit('loadedmetadata')) : g.reject(d) }; const k = function () { e._.isLoaded = !0, e._.plotFlush = !0, e._.emit('loadeddata'), g.resolveWith(e) }; return (new c.Decoder()).decode(d, j, k), g.promise() }; var e = function () { return d.apply(this, arguments), this } }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; d.biquad = new e(d.samplerate), d.freq = a(340), d.band = a(1), d.gain = a(0), d.plotBefore = g, d.plotRange = [-18, 18], d.plotFlush = !0 } var c = a.fn; const d = a.modules.FFT; var e = a.modules.Biquad; const f = 20; c.extend(b); var g = function (a, b, c, d, e) { a.lineWidth = 1, a.strokeStyle = 'rgb(192, 192, 192)'; for (var g = 0.5 * this._.samplerate, h = 1; h <= 10; ++h) { for (let i = 1; i <= 4; i++) { const j = h * 10 ** i; if (!(f >= j || j >= g)) { a.beginPath(); let k = Math.log(j / f) / Math.log(g / f); k = (k * d + b | 0) + 0.5, a.moveTo(k, c), a.lineTo(k, c + e), a.stroke() } } } const l = e / 6; for (h = 1; h < 6; h++) { a.beginPath(); const m = (c + h * l | 0) + 0.5; a.moveTo(b, m), a.lineTo(b + d, m), a.stroke() } }; const h = b.prototype; Object.defineProperties(h, { type: { set (a) { const b = this._; a !== b.biquad.type && (b.biquad.setType(a), b.plotFlush = !0) }, get () { return this._.biquad.type } }, freq: { set (b) { this._.freq = a(b) }, get () { return this._.freq } }, cutoff: { set (b) { this._.freq = a(b) }, get () { return this._.freq } }, res: { set (b) { this._.band = a(b) }, get () { return this._.band } }, Q: { set (b) { this._.band = a(b) }, get () { return this._.band } }, band: { set (b) { this._.band = a(b) }, get () { return this._.band } }, gain: { set (b) { this._.gain = a(b) }, get () { return this._.gain } } }), h.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a, c.inputSignalAR(this); const d = b.freq.process(a).cells[0][0]; const e = b.band.process(a).cells[0][0]; const f = b.gain.process(a).cells[0][0]; (b.prevFreq !== d || b.prevband !== e || b.prevGain !== f) && (b.prevFreq = d, b.prevband = e, b.prevGain = f, b.biquad.setParams(d, e, f), b.plotFlush = !0), b.bypassed || b.biquad.process(this.cells[1], this.cells[2]), c.outputSignalAR(this) } return this }; const i = new d(2048); const j = a.Object.prototype.plot; h.plot = function (a) { if (this._.plotFlush) { const b = new e(this._.samplerate); b.setType(this.type), b.setParams(this.freq.valueOf(), this.band.valueOf(), this.gain.valueOf()); const c = new Float32Array(i.length); c[0] = 1, b.process(c, c), i.forward(c); let d; let g; let h; let k; let l; let m; let n; let o; const p = 512; const q = new Float32Array(p); const r = 0.5 * this._.samplerate; const s = new Float32Array(p); for (i.getFrequencyData(s), d = 0; p > d; ++d) { h = (r / f) ** (d / p) * f, g = h / (r / s.length), k = 0 | g, l = g - k, k === 0 ? n = m = o = s[k] : (m = s[k - 1], n = s[k], o = (1 - l) * m + l * n), q[d] = o } this._.plotData = q, this._.plotFlush = null } return j.call(this, a) }, c.register('biquad', b), c.register('lowpass', function (a) { return new b(a).set('type', 'lowpass') }), c.register('highpass', function (a) { return new b(a).set('type', 'highpass') }), c.register('bandpass', function (a) { return new b(a).set('type', 'bandpass') }), c.register('lowshelf', function (a) { return new b(a).set('type', 'lowshelf') }), c.register('highshelf', function (a) { return new b(a).set('type', 'highshelf') }), c.register('peaking', function (a) { return new b(a).set('type', 'peaking') }), c.register('notch', function (a) { return new b(a).set('type', 'notch') }), c.register('allpass', function (a) { return new b(a).set('type', 'allpass') }), c.alias('lpf', 'lowpass'), c.alias('hpf', 'highpass'), c.alias('bpf', 'bandpass'), c.alias('bef', 'notch'), c.alias('brf', 'notch'), c.alias('apf', 'allpass') }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), c.fixAR(this); const d = this._; d.pitch = a(1), d.samplerate = 44100, d.channels = 0, d.bufferMix = null, d.buffer = [], d.isLooped = !1, d.isReversed = !1, d.duration = 0, d.currentTime = 0, d.currentTimeObj = null, d.phase = 0, d.phaseIncr = 0, d.onended = c.make_onended(this, 0), d.onlooped = f(this) } var c = a.fn; const d = a.modules.Scissor.Tape; const e = function (a) { return c.isSignalArray(a) || a instanceof Float32Array }; c.extend(b); var f = function (a) { return function () { const b = a._; b.phase >= b.buffer[0].length ? b.phase = 0 : b.phase < 0 && (b.phase = b.buffer[0].length + b.phaseIncr), a._.emit('looped') } }; const g = b.prototype; const h = function (b) { const c = this._; if (typeof b === 'object') { let f; let g; let h = []; e(b) ? (h[0] = b, g = 1) : typeof b === 'object' && (b instanceof a.Object ? b = b.buffer : b instanceof d && (b = b.getBuffer()), Array.isArray(b.buffer) ? e(b.buffer[0]) && (e(b.buffer[1]) && e(b.buffer[2]) ? (g = 2, h = b.buffer) : (g = 1, h = [b.buffer[0]])) : e(b.buffer) && (g = 1, h = [b.buffer]), typeof b.samplerate === 'number' && (f = b.samplerate)), h.length && (f > 0 && (c.samplerate = b.samplerate), c.bufferMix = null, c.buffer = h, c.phase = 0, c.phaseIncr = c.samplerate / a.samplerate, c.duration = 1e3 * c.buffer[0].length / c.samplerate, c.currentTime = 0, c.plotFlush = !0, this.reverse(c.isReversed)) } }; Object.defineProperties(g, { buffer: { set: h, get () { const a = this._; return { samplerate: a.samplerate, channels: a.channels, buffer: a.buffer } } }, pitch: { set (b) { this._.pitch = a(b) }, get () { return this._.pitch } }, isLooped: { get () { return this._.isLooped } }, isReversed: { get () { return this._.isReversed } }, samplerate: { get () { return this._.samplerate } }, duration: { get () { return this._.duration } }, currentTime: { set (b) { if (typeof b === 'number') { const c = this._; b >= 0 && b <= c.duration && (c.phase = b / 1e3 * c.samplerate, c.currentTime = b) } else { b instanceof a.Object ? this._.currentTimeObj = b : b === null && (this._.currentTimeObj = null) } }, get () { return this._.currentTimeObj ? this._.currentTimeObj : this._.currentTime } } }), g.clone = function () { const a = this._; const b = c.clone(this); return a.buffer.length && h.call(b, { buffer: a.buffer, samplerate: a.samplerate, channels: a.channels }), b.loop(a.isLooped), b.reverse(a.isReversed), b }, g.slice = function (b, d) { const e = this._; const f = a(e.originkey); let g = e.isReversed; if (e.buffer.length) { if (b = typeof b === 'number' ? 0.001 * b * e.samplerate | 0 : 0, d = typeof d === 'number' ? 0.001 * d * e.samplerate | 0 : e.buffer[0].length, b > d) { const i = b; b = d, d = i, g = !g }e.channels === 2 ? h.call(f, { buffer: [c.pointer(e.buffer[0], b, d - b), c.pointer(e.buffer[1], b, d - b), c.pointer(e.buffer[2], b, d - b)], samplerate: e.samplerate }) : h.call(f, { buffer: c.pointer(e.buffer[0], b, d - b), samplerate: e.samplerate }), f.playbackState = c.PLAYING_STATE } return f.loop(e.isLooped), f.reverse(e.isReversed), f }, g.reverse = function (a) { const b = this._; return b.isReversed = !!a, b.isReversed ? (b.phaseIncr > 0 && (b.phaseIncr *= -1), b.phase === 0 && b.buffer.length && (b.phase = b.buffer[0].length + b.phaseIncr)) : b.phaseIncr < 0 && (b.phaseIncr *= -1), this }, g.loop = function (a) { return this._.isLooped = !!a, this }, g.bang = function (a) { return this.playbackState = a === !1 ? c.FINISHED_STATE : c.PLAYING_STATE, this._.phase = 0, this._.emit('bang'), this }, g.process = function (a) { const b = this._; if (!b.buffer.length) { return this } if (this.tickID !== a) { this.tickID = a; let d; let e; let f; const g = this.cells[1]; const h = this.cells[2]; let i = b.phase; const j = b.cellsize; if (b.channels === 2 ? (e = b.buffer[1], f = b.buffer[2]) : e = f = b.buffer[0], b.currentTimeObj) { let k; const l = b.currentTimeObj.process(a).cells[0]; const m = 0.001 * b.samplerate; for (d = 0; j > d; ++d) { k = l[d], i = k * m, g[d] = e[0 | i] || 0, h[d] = f[0 | i] || 0 }b.phase = i, b.currentTime = k } else { const n = b.pitch.process(a).cells[0][0]; const o = b.phaseIncr * n; for (d = 0; j > d; ++d) { g[d] = e[0 | i] || 0, h[d] = f[0 | i] || 0, i += o }i >= e.length ? c.nextTick(b.isLooped ? b.onlooped : b.onended) : i < 0 && c.nextTick(b.isLooped ? b.onlooped : b.onended), b.phase = i, b.currentTime += c.currentTimeIncr }c.outputSignalAR(this) } return this }; const i = a.Object.prototype.plot; g.plot = function (a) { let b; let c; const d = this._; if (d.plotFlush) { d.channels === 2 ? (b = d.buffer[1], c = d.buffer[2]) : b = c = d.buffer[0]; for (var e = new Float32Array(2048), f = 0, g = b.length / 2048, h = 0; h < 2048; h++) { e[h] = 0.5 * (b[0 | f] + c[0 | f]), f += g }d.plotData = e, d.plotFlush = null } return i.call(this, a) }, c.register('buffer', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const e = new d(this._.samplerate); e.setDelayTime(20), e.setRate(4), e.depth = 20, e.feedback = 0.2, e.mix = 0.33, this._.chorus = e } var c = a.fn; var d = a.modules.Chorus; c.extend(b); const e = b.prototype; Object.defineProperties(e, { type: { set (a) { this._.chorus.setDelayTime(a) }, get () { return this._.chorus.wave } }, delay: { set (a) { a >= 0.5 && a <= 80 && this._.chorus.setDelayTime(a) }, get () { return this._.chorus.delayTime } }, rate: { set (a) { typeof a === 'number' && a > 0 && this._.chorus.setRate(a) }, get () { return this._.chorus.rate } }, depth: { set (a) { typeof a === 'number' && a >= 0 && a <= 100 && (a *= this._.samplerate / 44100, this._.chorus.depth = a) }, get () { return this._.chorus.depth } }, fb: { set (a) { typeof a === 'number' && a >= -1 && a <= 1 && (this._.chorus.feedback = 0.99996 * a) }, get () { return this._.chorus.feedback } }, mix: { set (b) { this._.mix = a(b) }, get () { return this._.mix } } }), e.process = function (a) { const b = this._; return this.tickID !== a && (this.tickID = a, c.inputSignalAR(this), b.bypassed || b.chorus.process(this.cells[1], this.cells[2]), c.outputSignalAR(this)), this }, c.register('chorus', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b); const c = this._; c.min = -0.8, c.max = 0.8 } const c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { minmax: { set (a) { const b = this._; typeof a === 'number' && (b.min = -Math.abs(a), b.max = -b.min) }, get () { return this._.max } }, min: { set (a) { const b = this._; typeof a === 'number' && (b.max < a ? b.max = a : b.min = a) }, get () { return this._.min } }, max: { set (a) { const b = this._; typeof a === 'number' && (a < b.min ? b.min = a : b.max = a) }, get () { return this._.max } } }), d.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; let e; const f = this.cells[1]; const g = this.cells[2]; const h = f.length; const i = b.min; const j = b.max; if (b.ar) { for (c.inputSignalAR(this), d = 0; h > d; ++d) { e = f[d], i > e ? e = i : e > j && (e = j), f[d] = e, e = g[d], i > e ? e = i : e > j && (e = j), g[d] = e }c.outputSignalAR(this) } else { e = c.inputSignalKR(this), i > e ? e = i : e > j && (e = j), this.cells[0][0] = e, c.outputSignalKR(this) } } return this }, c.register('clip', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; d.prevThresh = -24, d.prevKnee = 30, d.prevRatio = 12, d.thresh = a(d.prevThresh), d.knee = a(d.prevKnee), d.ratio = a(d.prevRatio), d.postGain = 6, d.reduction = 0, d.attack = 3, d.release = 25, d.comp = new e(d.samplerate), d.comp.dbPostGain = d.postGain, d.comp.setAttackTime(0.001 * d.attack), d.comp.setReleaseTime(0.001 * d.release), d.comp.setPreDelayTime(6), d.comp.setParams(d.prevThresh, d.prevKnee, d.prevRatio) } var c = a.fn; const d = a.timevalue; var e = a.modules.Compressor; c.extend(b); const f = b.prototype; Object.defineProperties(f, { thresh: { set (b) { this._.thresh = a(b) }, get () { return this._.thresh } }, thre: { set (b) { this._.thresh = a(b) }, get () { return this._.thre } }, knee: { set (b) { this._.kne = a(b) }, get () { return this._.knee } }, ratio: { set (b) { this._.ratio = a(b) }, get () { return this._.ratio } }, gain: { set (a) { typeof a === 'number' && (this._.comp.dbPostGain = a) }, get () { return this._.comp.dbPostGain } }, attack: { set (a) { typeof a === 'string' && (a = d(a)), typeof a === 'number' && (a = a < 0 ? 0 : a > 1e3 ? 1e3 : a, this._.attack = a, this._.comp.setAttackTime(0.001 * a)) }, get () { return this._.attack } }, release: { set (a) { typeof a === 'string' && (a = d(a)), typeof a === 'number' && (a = a < 0 ? 0 : a > 1e3 ? 1e3 : a, this._.release = a, this._.comp.setReleaseTime(0.001 * a)) }, get () { return this._.release } }, reduction: { get () { return this._.reduction } } }), f.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a, c.inputSignalAR(this); const d = b.thresh.process(a).cells[0][0]; const e = b.knee.process(a).cells[0][0]; const f = b.ratio.process(a).cells[0][0]; (b.prevThresh !== d || b.prevKnee !== e || b.prevRatio !== f) && (b.prevThresh = d, b.prevKnee = e, b.prevRatio = f, b.comp.setParams(d, e, f)), b.bypassed || (b.comp.process(this.cells[1], this.cells[2]), b.reduction = b.comp.meteringGain), c.outputSignalAR(this) } return this }, c.register('comp', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; d.time = a(100), d.fb = a(0.2), d.cross = a(!1), d.mix = 0.33, d.delay = new e(d.samplerate) } var c = a.fn; const d = a.timevalue; var e = a.modules.StereoDelay; c.extend(b); const f = b.prototype; Object.defineProperties(f, { time: { set (b) { typeof b === 'string' && (b = d(b)), this._.time = a(b) }, get () { return this._.time } }, fb: { set (b) { this._.fb = a(b) }, get () { return this._.fb } }, cross: { set (b) { this._.cross = a(b) }, get () { return this._.cross } }, mix: { set (a) { typeof a === 'number' && (a = a > 1 ? 1 : a < 0 ? 0 : a, this._.mix = a) }, get () { return this._.mix } } }), f.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; const d = b.time.process(a).cells[0][0]; const e = b.fb.process(a).cells[0][0]; const f = b.cross.process(a).cells[0][0] !== 0; const g = b.mix; (b.prevTime !== d || b.prevFb !== e || b.prevCross !== f || b.prevMix !== g) && (b.prevTime = d, b.prevFb = e, b.prevCross = f, b.prevMix = g, b.delay.setParams(d, e, f, g)), c.inputSignalAR(this), b.bypassed || b.delay.process(this.cells[1], this.cells[2]), c.outputSignalAR(this) } return this }, c.register('delay', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; d.pre = a(60), d.post = a(-18), d.x1L = d.x2L = d.y1L = d.y2L = 0, d.x1R = d.x2R = d.y1R = d.y2R = 0, d.b0 = d.b1 = d.b2 = d.a1 = d.a2 = 0, d.cutoff = 0, d.Q = 1, d.preScale = 0, d.postScale = 0 } var c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { cutoff: { set (a) { typeof a === 'number' && a > 0 && (this._.cutoff = a) }, get () { return this._.cutoff } }, pre: { set (b) { this._.pre = a(b) }, get () { return this._.pre } }, post: { set (b) { this._.post = a(b) }, get () { return this._.post } } }), d.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a, c.inputSignalAR(this); const d = -b.pre.process(a).cells[0][0]; const f = -b.post.process(a).cells[0][0]; if ((b.prevPreGain !== d || b.prevPostGain !== f) && (b.prevPreGain = d, b.prevPostGain = f, b.preScale = 10 ** (0.05 * -d), b.postScale = 10 ** (0.05 * -f)), !b.bypassed) { let g; let h; let i; let j; let k; const l = this.cells[1]; const m = this.cells[2]; const n = b.preScale; const o = b.postScale; if (b.cutoff) { b.prevCutoff !== b.cutoff && (b.prevCutoff = b.cutoff, e(b)); let p = b.x1L; let q = b.x2L; let r = b.y1L; let s = b.y2L; let t = b.x1R; let u = b.x2R; let v = b.y1R; let w = b.y2R; const x = b.b0; const y = b.b1; const z = b.b2; const A = b.a1; const B = b.a2; for (g = 0, h = l.length; h > g; ++g) { j = l[g] * n, k = x * j + y * p + z * q - A * r - B * s, i = k * o, i < -1 ? i = -1 : i > 1 && (i = 1), l[g] = i, q = p, p = j, s = r, r = k, j = m[g] * n, k = x * j + y * t + z * u - A * v - B * w, i = k * o, i < -1 ? i = -1 : i > 1 && (i = 1), m[g] = i, u = t, t = j, w = v, v = k }b.x1L = p, b.x2L = q, b.y1L = r, b.y2L = s, b.x1R = t, b.x2R = u, b.y1R = v, b.y2R = w } else { for (g = 0, h = l.length; h > g; ++g) { i = l[g] * n * o, i < -1 ? i = -1 : i > 1 && (i = 1), l[g] = i, i = m[g] * n * o, i < -1 ? i = -1 : i > 1 && (i = 1), m[g] = i } } }c.outputSignalAR(this) } return this }; var e = function (a) { const b = 2 * Math.PI * a.cutoff / a.samplerate; const c = Math.cos(b); const d = Math.sin(b); const e = d / (2 * a.Q); const f = 1 / (1 + e); a.b0 = 0.5 * (1 - c) * f, a.b1 = 1 - c * f, a.b2 = 0.5 * (1 - c) * f, a.a1 = -2 * c * f, a.a2 = 1 - e * f }; c.register('dist', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), this._.ar = !1 } const c = a.fn; c.extend(b); const d = b.prototype; d.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; let e; let f; let g; let h; let i; const j = this.nodes; const k = this.cells[0]; const l = this.cells[1]; const m = this.cells[2]; const n = j.length; const o = k.length; if (b.ar) { if (j.length > 0) { for (j[0].process(a), g = j[0].cells[1], h = j[0].cells[2], l.set(g), m.set(h), d = 1; n > d; ++d) { for (j[d].process(a), g = j[d].cells[1], h = j[d].cells[2], e = 0; o > e; ++e) { i = g[e], l[e] = i === 0 ? 0 : l[e] / i, i = h[e], m[e] = i === 0 ? 0 : m[e] / i } } } else { for (e = 0; o > e; ++e) { l[e] = m[d] = 0 } }c.outputSignalAR(this) } else { if (j.length > 0) { for (f = j[0].process(a).cells[0][0], d = 1; n > d; ++d) { i = j[d].process(a).cells[0][0], f = i === 0 ? 0 : f / i } } else { f = 0 }k[0] = f, c.outputSignalKR(this) } } return this }, c.register('/', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b); const c = this._; c.env = new f(c.samplerate), c.env.setStep(c.cellsize), c.tmp = new d.SignalArray(c.cellsize), c.ar = !1, c.plotFlush = !0, c.onended = i(this), this.on('ar', h) } function c (a, b, c, d, e, f) { let g = c; return typeof a[d] === 'number' ? g = a[d] : typeof a[e] === 'number' ? g = a[e] : f && (typeof a[d] === 'string' ? g = f(a[d]) : typeof a[e] === 'string' && (g = f(a[e]))), b > g && (g = b), g } var d = a.fn; const e = a.timevalue; var f = a.modules.Envelope; const g = d.isDictionary; d.extend(b); var h = function (a) { this._.env.setStep(a ? 1 : this._.cellsize) }; var i = function (a) { return function () { a._.emit('ended') } }; const j = b.prototype; Object.defineProperties(j, { table: { set (a) { Array.isArray(a) && (k.call(this, a), this._.plotFlush = !0) }, get () { return this._.env.table } }, curve: { set (a) { this._.env.setCurve(a) }, get () { return this._.env.curve } }, releaseNode: { set (a) { this._.env.setReleaseNode(a), this._.plotFlush = !0 }, get () { return this._.env.releaseNode + 1 } }, loopNode: { set (a) { this._.env.setLoopNode(a), this._.plotFlush = !0 }, get () { return this._.env.loopNode + 1 } } }), j.clone = function () { const a = d.clone(this); return a._.env = this._.env.clone(), a }, j.reset = function () { return this._.env.reset(), this }, j.release = function () { const a = this._; return a.env.release(), a.emit('released'), this }, j.bang = function () { const a = this._; return a.env.reset(), a.env.status = f.StatusGate, a.emit('bang'), this }, j.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let c; const e = this.cells[1]; const f = this.cells[2]; const g = b.cellsize; if (this.nodes.length) { d.inputSignalAR(this) } else { for (c = 0; g > c; ++c) { e[c] = f[c] = 1 } } let h; let i = null; if (b.ar) { const j = b.tmp; for (b.env.process(j), c = 0; g > c; ++c) { e[c] *= j[c], f[c] *= j[c] }i = b.env.emit } else { for (h = b.env.next(), c = 0; g > c; ++c) { e[c] *= h, f[c] *= h }i = b.env.emit }d.outputSignalAR(this), i && (i === 'ended' ? d.nextTick(b.onended) : this._.emit(i, b.value)) } return this }; var k = function (a) { for (var b, c, d, g, h = this._.env, i = [a[0] || m], j = 1, k = a.length; k > j; ++j) { b = a[j][0] || m, c = a[j][1], d = a[j][2], typeof c !== 'number' && (c = typeof c === 'string' ? e(c) : 10), c < 10 && (c = 10), typeof d === 'number' ? (g = d, d = f.CurveTypeCurve) : (d = f.CurveTypeDict[d] || null, g = 0), i.push([b, c, d, g]) }h.setTable(i) }; const l = a.Object.prototype.plot; j.plot = function (a) { if (this._.plotFlush) { let b; let c; const d = this._.env.clone(); const e = d.getInfo(1e3); const g = e.totalDuration; const h = e.loopBeginTime; const i = e.releaseBeginTime; const j = new Float32Array(256); let k = 0; const m = g / j.length; let n = !1; let o = 0.001 * g * this._.samplerate | 0; for (o /= j.length, d.setStep(o), d.status = f.StatusGate, b = 0, c = j.length; c > b; ++b) { j[b] = d.next(), k += m, !n && k >= i && (d.release(), n = !0) } this._.plotData = j, this._.plotBefore = function (a, b, c, d, e) { let f, j; 1 / 0 !== h && 1 / 0 !== i && (f = b + d * (h / g), j = b + d * (i / g), j -= f, a.fillStyle = 'rgba(224, 224, 224, 0.8)', a.fillRect(f, 0, j, e)), 1 / 0 !== i && (f = b + d * (i / g), j = d - f, a.fillStyle = 'rgba(212, 212, 212, 0.8)', a.fillRect(f, 0, j, e)) }; let p = 1 / 0; let q = -1 / 0; for (b = 0; c > b; ++b) { j[b] < p ? p = j[b] : j[b] > q && (q = j[b]) }q < 1 && (q = 1), this._.plotRange = [p, q], this._.plotData = j, this._.plotFlush = null } return l.call(this, a) }, d.register('env', b); var m = f.ZERO; d.register('perc', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; const f = c(d, 10, 10, 'a', 'attackTime', e); const h = c(d, 10, 1e3, 'r', 'releaseTime', e); const i = c(d, m, 1, 'lv', 'level'); return d.table = [m, [i, f], [m, h]], new b(a) }), d.register('adsr', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; const f = c(d, 10, 10, 'a', 'attackTime', e); const h = c(d, 10, 300, 'd', 'decayTime', e); const i = c(d, m, 0.5, 's', 'sustainLevel'); const j = c(d, 10, 1e3, 'r', 'decayTime', e); const k = c(d, m, 1, 'lv', 'level'); return d.table = [m, [k, f], [i, h], [m, j]], d.releaseNode = 3, new b(a) }), d.register('adshr', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; const f = c(d, 10, 10, 'a', 'attackTime', e); const h = c(d, 10, 300, 'd', 'decayTime', e); const i = c(d, m, 0.5, 's', 'sustainLevel'); const j = c(d, 10, 500, 'h', 'holdTime', e); const k = c(d, 10, 1e3, 'r', 'decayTime', e); const l = c(d, m, 1, 'lv', 'level'); return d.table = [m, [l, f], [i, h], [i, j], [m, k]], new b(a) }), d.register('asr', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; const f = c(d, 10, 10, 'a', 'attackTime', e); const h = c(d, m, 0.5, 's', 'sustainLevel'); const i = c(d, 10, 1e3, 'r', 'releaseTime', e); return d.table = [m, [h, f], [m, i]], d.releaseNode = 2, new b(a) }), d.register('dadsr', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; const f = c(d, 10, 100, 'dl', 'delayTime', e); const h = c(d, 10, 10, 'a', 'attackTime', e); const i = c(d, 10, 300, 'd', 'decayTime', e); const j = c(d, m, 0.5, 's', 'sustainLevel'); const k = c(d, 10, 1e3, 'r', 'relaseTime', e); const l = c(d, m, 1, 'lv', 'level'); return d.table = [m, [m, f], [l, h], [j, i], [m, k]], d.releaseNode = 4, new b(a) }), d.register('ahdsfr', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; const f = c(d, 10, 10, 'a', 'attackTime', e); const h = c(d, 10, 10, 'h', 'holdTime', e); const i = c(d, 10, 300, 'd', 'decayTime', e); const j = c(d, m, 0.5, 's', 'sustainLevel'); const k = c(d, 10, 5e3, 'f', 'fadeTime', e); const l = c(d, 10, 1e3, 'r', 'relaseTime', e); const n = c(d, m, 1, 'lv', 'level'); return d.table = [m, [n, f], [n, h], [j, i], [m, k], [m, l]], d.releaseNode = 5, new b(a) }), d.register('linen', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; const f = c(d, 10, 10, 'a', 'attackTime', e); const h = c(d, 10, 1e3, 's', 'sustainTime', e); const i = c(d, 10, 1e3, 'r', 'releaseTime', e); const j = c(d, m, 1, 'lv', 'level'); return d.table = [m, [j, f], [j, h], [m, i]], new b(a) }), d.register('env.tri', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; let f = c(d, 20, 1e3, 'dur', 'duration', e); const h = c(d, m, 1, 'lv', 'level'); return f *= 0.5, d.table = [m, [h, f], [m, f]], new b(a) }), d.register('env.cutoff', function (a) { g(a[0]) || a.unshift({}); const d = a[0]; const f = c(d, 10, 100, 'r', 'relaseTime', e); const h = c(d, m, 1, 'lv', 'level'); return d.table = [h, [m, f]], new b(a) }) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; d.biquads = new Array(7), d.plotBefore = h, d.plotRange = [-18, 18], d.plotFlush = !0 } var c = a.fn; const d = a.modules.FFT; const e = a.modules.Biquad; const f = 20; const g = { hpf: 0, lf: 1, lmf: 2, mf: 3, hmf: 4, hf: 5, lpf: 6 }; c.extend(b); var h = function (a, b, c, d, e) { a.lineWidth = 1, a.strokeStyle = 'rgb(192, 192, 192)'; for (var g = 0.5 * this._.samplerate, h = 1; h <= 10; ++h) { for (let i = 1; i <= 4; i++) { const j = h * 10 ** i; if (!(f >= j || j >= g)) { a.beginPath(); let k = Math.log(j / f) / Math.log(g / f); k = (k * d + b | 0) + 0.5, a.moveTo(k, c), a.lineTo(k, c + e), a.stroke() } } } const l = e / 6; for (h = 1; h < 6; h++) { a.beginPath(); const m = (c + h * l | 0) + 0.5; a.moveTo(b, m), a.lineTo(b + d, m), a.stroke() } }; const i = b.prototype; Object.defineProperties(i, { params: { set (a) { if (typeof a === 'object') { for (let b = Object.keys(a), c = 0, d = b.length; d > c; ++c) { const e = a[b[c]]; Array.isArray(e) ? this.setParams(b[c], e[0], e[1], e[2]) : this.setParams(b[c]) } } } } }), i.setParams = function (a, b, c, d) { const f = this._; if (typeof a === 'string' && (a = g[a]), a >= 0 && a < f.biquads.length) { if (a |= 0, typeof b === 'number' && typeof c === 'number') { typeof d !== 'number' && (d = 0); let h = f.biquads[a]; if (!h) { switch (h = f.biquads[a] = new e(f.samplerate), a) { case 0:h.setType('highpass'); break; case f.biquads.length - 1:h.setType('lowpass'); break; default:h.setType('peaking') } }h.setParams(b, c, d) } else { f.biquads[a] = void 0 }f.plotFlush = !0 } return this }, i.getParams = function (a) { const b = this._; const c = b.biquads[0 | a]; return c ? { freq: c.frequency, Q: c.Q, gain: c.gain } : void 0 }, i.process = function (a) { const b = this._; if (this.tickID !== a) { if (this.tickID = a, c.inputSignalAR(this), !b.bypassed) { for (let d = this.cells[1], e = this.cells[2], f = b.biquads, g = 0, h = f.length; h > g; ++g) { f[g] && f[g].process(d, e) } }c.outputSignalAR(this) } return this }; const j = new d(2048); const k = a.Object.prototype.plot; i.plot = function (a) { if (this._.plotFlush) { const b = this._; const c = new Float32Array(j.length); c[0] = 1; for (var d = 0, g = b.biquads.length; g > d; ++d) { const h = this.getParams(d); if (h) { const i = new e(b.samplerate); i.setType(d === 0 ? 'highpass' : d === g - 1 ? 'lowpass' : 'peaking'), i.setParams(h.freq, h.Q, h.gain), i.process(c, c) } }j.forward(c); let l; let m; let n; let o; let p; let q; let r; const s = 512; const t = new Float32Array(s); const u = 0.5 * b.samplerate; const v = new Float32Array(s); for (j.getFrequencyData(v), d = 0; s > d; ++d) { m = (u / f) ** (d / s) * f, l = m / (u / v.length), n = 0 | l, o = l - n, n === 0 ? q = p = r = v[n] : (p = v[n - 1], q = v[n], r = (1 - o) * p + o * q), t[d] = r } this._.plotData = t, this._.plotFlush = null } return k.call(this, a) }, c.register('eq', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.listener(this), c.fixAR(this), this.real = new a.ChannelObject(this), this.imag = new a.ChannelObject(this), this.cells[3] = this.real.cell, this.cells[4] = this.imag.cell; const e = this._; e.fft = new d(2 * e.cellsize), e.fftCell = new c.SignalArray(e.fft.length), e.prevCell = new c.SignalArray(e.cellsize), e.freqs = new c.SignalArray(e.fft.length >> 1), e.plotFlush = !0, e.plotRange = [0, 32], e.plotBarStyle = !0 } var c = a.fn; var d = a.modules.FFT; c.extend(b); const e = b.prototype; Object.defineProperties(e, { window: { set (a) { this._.fft.setWindow(a) }, get () { return this._.fft.windowName } }, spectrum: { get () { return this._.fft.getFrequencyData(this._.freqs) } } }), e.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a, c.inputSignalAR(this), c.outputSignalAR(this); const d = this.cells[0]; const e = b.cellsize; b.fftCell.set(b.prevCell), b.fftCell.set(d, e), b.fft.forward(b.fftCell), b.prevCell.set(d), b.plotFlush = !0, this.cells[3].set(b.fft.real.subarray(0, e)), this.cells[4].set(b.fft.imag.subarray(0, e)) } return this }; const f = a.Object.prototype.plot; e.plot = function (a) { return this._.plotFlush && (this._.plotData = this.spectrum, this._.plotFlush = null), f.call(this, a) }, c.register('fft', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), c.fixAR(this); const d = this._; d.freq = a(440), d.reg = 32768, d.shortFlag = !1, d.phase = 0, d.lastValue = 0 } var c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { shortFlag: { set (a) { this._.shortFlag = !!a }, get () { return this._.shortFlag } }, freq: { set (b) { this._.freq = a(b) }, get () { return this._.freq } } }), d.process = function (a) { const b = this._; const c = this.cells[0]; if (this.tickID !== a) { this.tickID = a; let d; let e; let f = b.lastValue; let g = b.phase; const h = b.freq.process(a).cells[0][0] / b.samplerate; let i = b.reg; const j = b.mul; const k = b.add; if (b.shortFlag) { for (d = 0, e = c.length; e > d; ++d) { g >= 1 && (i >>= 1, i |= (1 & (i ^ i >> 6)) << 15, f = (1 & i) - 0.5, g -= 1), c[d] = f * j + k, g += h } } else { for (d = 0, e = c.length; e > d; ++d) { g >= 1 && (i >>= 1, i |= (1 & (i ^ i >> 1)) << 15, f = (1 & i) - 0.5, g -= 1), c[d] = f * j + k, g += h } }b.reg = i, b.phase = g, b.lastValue = f } return this }, c.register('fnoise', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this), this._.selected = 0, this._.outputs = [] } var c = a.fn; const d = (function () { function b (b) { a.Object.call(this, 2, []), c.fixAR(this), this._.parent = b } return c.extend(b), b.prototype.process = function (a) { return this.tickID !== a && (this.tickID = a, this._.parent.process(a)), this }, b }()); c.extend(b); const e = b.prototype; Object.defineProperties(e, { selected: { set (a) { const b = this._; if (typeof a === 'number') { b.selected = a; for (let d = b.outputs, e = 0, f = d.length; f > e; ++e) { d[e] && (d[e].cells[0].set(c.emptycell), d[e].cells[1].set(c.emptycell), d[e].cells[2].set(c.emptycell)) } } }, get () { return this._.selected } } }), e.at = function (a) { const b = this._; let c = b.outputs[a]; return c || (b.outputs[a] = c = new d(this)), c }, e.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a, c.inputSignalAR(this), c.outputSignalAR(this); const d = b.outputs[b.selected]; d && (d.cells[0].set(this.cells[0]), d.cells[1].set(this.cells[1]), d.cells[2].set(this.cells[2])) } return this }, c.register('gate', b) }(timbre)), (function (a) {
  'use strict'; function b (b) { a.Object.call(this, 1, b), c.fixAR(this); const e = this._; e.fft = new d(2 * e.cellsize), e.fftCell = new c.SignalArray(this._.fft.length), e.realBuffer = new c.SignalArray(this._.fft.length), e.imagBuffer = new c.SignalArray(this._.fft.length) } var c = a.fn; var d = a.modules.FFT; c.extend(b); const e = b.prototype
  Object.defineProperties(e, { real: { set (b) { this._.real = a(b) }, get () { return this._.real } }, imag: { set (b) { this._.imag = a(b) }, get () { return this._.imag } } }), e.process = function (a) { const b = this._; if (this.tickID !== a && (this.tickID = a, b.real && b.imag)) { const d = this.cells[0]; const e = b.realBuffer; const f = b.imagBuffer; const g = b.real.process(a).cells[0]; const h = b.imag.process(a).cells[0]; e.set(g), f.set(h), d.set(b.fft.inverse(e, f).subarray(0, b.cellsize)), c.outputSignalAR(this) } return this }, c.register('ifft', b)
}(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), c.timer(this), c.fixKR(this); const d = this._; d.interval = a(1e3), d.count = 0, d.delay = 0, d.timeout = 1 / 0, d.currentTime = 0, d.delaySamples = 0, d.countSamples = 0, d.onended = c.make_onended(this), this.on('start', e) } var c = a.fn; const d = a.timevalue; c.extend(b); var e = function () { const a = this._; this.playbackState = c.PLAYING_STATE, a.delaySamples = 0.001 * a.samplerate * a.delay | 0, a.countSamples = a.count = a.currentTime = 0 }; Object.defineProperty(e, 'unremovable', { value: !0, writable: !1 }); const f = b.prototype; Object.defineProperties(f, { interval: { set (b) { typeof b === 'string' && (b = d(b), b <= 0 && (b = 0)), this._.interval = a(b) }, get () { return this._.interval } }, delay: { set (a) { typeof a === 'string' && (a = d(a)), typeof a === 'number' && a >= 0 && (this._.delay = a, this._.delaySamples = 0.001 * this._.samplerate * a | 0) }, get () { return this._.delay } }, count: { set (a) { typeof a === 'number' && (this._.count = a) }, get () { return this._.count } }, timeout: { set (a) { typeof a === 'string' && (a = d(a)), typeof a === 'number' && a >= 0 && (this._.timeout = a) }, get () { return this._.timeout } }, currentTime: { get () { return this._.currentTime } } }), f.bang = function () { const a = this._; return this.playbackState = c.PLAYING_STATE, a.delaySamples = 0.001 * a.samplerate * a.delay | 0, a.countSamples = a.count = a.currentTime = 0, a.emit('bang'), this }, f.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { this.tickID = a, d.delaySamples > 0 && (d.delaySamples -= b.length); const e = d.interval.process(a).cells[0][0]; if (d.delaySamples <= 0 && (d.countSamples -= b.length, d.countSamples <= 0)) { d.countSamples += d.samplerate * e * 0.001 | 0; for (var f = this.nodes, g = d.count, h = g * d.mul + d.add, i = 0, j = b.length; j > i; ++i) { b[i] = h } for (let k = 0, l = f.length; l > k; ++k) { f[k].bang(g) }d.count += 1 }d.currentTime += c.currentTimeIncr, d.currentTime >= d.timeout && c.nextTick(d.onended) } return this }, c.register('interval', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), c.fixAR(this); const d = this._; const e = Math.ceil(Math.log(d.samplerate) * Math.LOG2E); d.buffersize = 1 << e, d.buffermask = d.buffersize - 1, d.buffer = new c.SignalArray(d.buffersize), d.time = 0, d.readIndex = 0, d.writeIndex = 0 } var c = a.fn; const d = a.timevalue; c.extend(b); const e = b.prototype; Object.defineProperties(e, { time: { set (a) { if (typeof a === 'string' && (a = d(a)), typeof a === 'number' && a > 0) { const b = this._; b.time = a; let c = 0.001 * a * b.samplerate | 0; c > b.buffermask && (c = b.buffermask), b.writeIndex = b.readIndex + c & b.buffermask } }, get () { return this._.time } } }), e.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a, c.inputSignalAR(this); let d; const e = this.cells[0]; const f = b.buffer; const g = b.buffermask; let h = b.readIndex; let i = b.writeIndex; const j = e.length; for (d = 0; j > d; ++d) { f[i] = e[d], e[d] = f[h], h += 1, i = i + 1 & g }b.readIndex = h & g, b.writeIndex = i, c.outputSignalAR(this) } return this }, c.register('lag', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b); const c = this._; c.input = 0, c.value = 0, c.prev = null, c.ar = !1, c.map = d } const c = a.fn; c.extend(b); var d = function (a) { return a }; const e = b.prototype; Object.defineProperties(e, { input: { set (a) { typeof a === 'number' && (this._.input = a) }, get () { return this._.input } }, map: { set (a) { typeof a === 'function' && (this._.map = a) }, get () { return this._.map } } }), e.bang = function () { return this._.prev = null, this._.emit('bang'), this }, e.at = function (a) { return this._.map ? this._.map(a) : 0 }, e.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { this.tickID = a; let e; const f = this.nodes.length; const g = b.length; if (d.ar && f) { c.inputSignalAR(this); const h = d.map; if (h) { for (e = 0; g > e; ++e) { b[e] = h(b[e]) } }d.value = b[g - 1], c.outputSignalAR(this) } else { const i = f ? c.inputSignalKR(this) : d.input; d.map && d.prev !== i && (d.prev = i, d.value = d.map(i)); const j = d.value * d.mul + d.add; for (e = 0; g > e; ++e) { b[e] = j } } } return this }, c.register('map', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b) } const c = a.fn; c.extend(b); const d = b.prototype; d.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { this.tickID = a; let e; let f; let g; let h; const i = this.nodes; const j = i.length; const k = b.length; if (d.ar) { if (i.length > 0) { for (g = i[0].process(a).cells[0], b.set(g), e = 1; j > e; ++e) { for (g = i[e].process(a).cells[0], f = 0; k > f; ++f) { h = g[f], b[f] < h && (b[f] = h) } } } else { for (f = 0; k > f; ++f) { b[f] = 0 } }c.outputSignalAR(this) } else { if (i.length > 0) { for (g = i[0].process(a).cells[0][0], e = 1; j > e; ++e) { h = i[e].process(a).cells[0][0], h > g && (g = h) } } else { g = 0 }b[0] = g, c.outputSignalKR(this) } } return this }, c.register('max', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const e = this._; e.src = e.func = null, e.bufferL = new c.SignalArray(d), e.bufferR = new c.SignalArray(d), e.readIndex = 0, e.writeIndex = 0, e.totalRead = 0, e.totalWrite = 0 } if (a.envtype === 'browser') { var c = a.fn; var d = 4096; const e = d - 1; c.extend(b); const f = b.prototype; f.listen = function (b) { const c = g[a.env]; c && (c.set.call(this, b), c.listen.call(this)) }, f.unlisten = function () { const b = g[a.env]; b && b.unlisten.call(this), this.cells[0].set(c.emptycell), this.cells[1].set(c.emptycell), this.cells[2].set(c.emptycell); for (let d = this._, e = d.bufferL, f = d.bufferR, h = 0, i = e.length; i > h; ++h) { e[h] = f[h] = 0 } }, f.process = function (a) { const b = this._; if (b.src === null) { return this } if (this.tickID !== a) { this.tickID = a; const d = b.cellsize; if (b.totalWrite > b.totalRead + d) { const f = b.readIndex; const g = f + d; this.cells[1].set(b.bufferL.subarray(f, g)), this.cells[2].set(b.bufferR.subarray(f, g)), b.readIndex = g & e, b.totalRead += d }c.outputSignalAR(this) } return this }; var g = {}; g.webkit = { set (a) { const b = this._; if (a instanceof HTMLMediaElement) { const d = c._audioContext; b.src = d.createMediaElementSource(a) } }, listen () { const a = this._; const b = c._audioContext; a.gain = b.createGainNode(), a.gain.gain.value = 0, a.node = b.createJavaScriptNode(1024, 2, 2), a.node.onaudioprocess = h(this), a.src.connect(a.node), a.node.connect(a.gain), a.gain.connect(b.destination) }, unlisten () { const a = this._; a.src && a.src.disconnect(), a.gain && a.gain.disconnect(), a.node && a.node.disconnect() } }; var h = function (a) { return function (b) { const c = a._; const d = b.inputBuffer; const f = d.length; const g = c.writeIndex; c.bufferL.set(d.getChannelData(0), g), c.bufferR.set(d.getChannelData(1), g), c.writeIndex = g + f & e, c.totalWrite += f } }; g.moz = { set (a) { const b = this._; a instanceof HTMLAudioElement && (b.src = a, b.istep = b.samplerate / a.mozSampleRate) }, listen () { const a = this._; const b = a.bufferL; const c = a.bufferR; let d = 0; let f = 0; a.src.mozChannels === 2 ? (a.x = 0, a.func = function (g) { let h; let i; let j = a.writeIndex; let k = a.totalWrite; const l = g.frameBuffer; const m = a.istep; const n = l.length; for (h = a.x, i = 0; n > i; i += 2) { for (h += m; h > 0;) { b[j] = 0.5 * (l[i] + d), c[j] = 0.5 * (l[i + 1] + f), j = j + 1 & e, ++k, h -= 1 }d = l[i], f = l[i + 1] }a.x = h, a.writeIndex = j, a.totalWrite = k }) : (a.x = 0, a.func = function (f) { let g; let h; let i = a.writeIndex; let j = a.totalWrite; const k = f.frameBuffer; const l = a.istep; const m = k.length; for (g = a.x, h = 0; m > h; ++h) { for (g += l; g >= 0;) { b[i] = c[i] = 0.5 * (k[h] + d), i = i + 1 & e, ++j, g -= 1 }d = k[h] }a.x = g, a.writeIndex = i, a.totalWrite = j }), a.src.addEventListener('MozAudioAvailable', a.func) }, unlisten () { const a = this._; a.func && (a.src.removeEventListener('MozAudioAvailable', a.func), a.func = null) } }, c.register('mediastream', b) } }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b); const c = this._; c.midi = 0, c.value = 0, c.prev = null, c.a4 = 440, c.ar = !1 } const c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { midi: { set (a) { typeof a === 'number' && (this._.midi = a) }, get () { return this._.midi } }, a4: { set (a) { typeof a === 'number' && (this._.a4 = a, this._.prev = null) }, get () { return this._.a4 } } }), d.bang = function () { return this._.prev = null, this._.emit('bang'), this }, d.at = function (a) { const b = this._; return b.a4 * 2 ** ((a - 69) / 12) }, d.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; const e = this.cells[0]; const f = this.nodes.length; const g = e.length; if (b.ar && f) { c.inputSignalAR(this); const h = b.a4; for (d = 0; g > d; ++d) { e[d] = h * 2 ** ((e[d] - 69) / 12) }b.value = e[g - 1], c.outputSignalAR(this) } else { const i = f ? c.inputSignalKR(this) : b.midi; b.prev !== i && (b.prev = i, b.value = b.a4 * 2 ** ((i - 69) / 12)), e[0] = b.value, c.outputSignalKR(this) } } return this }, c.register('midicps', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b); const c = this._; c.midi = 0, c.value = 0, c.prev = null, c.range = 12, c.ar = !1 } const c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { midi: { set (a) { typeof a === 'number' && (this._.midi = a) }, get () { return this._.midi } }, range: { set (a) { typeof a === 'number' && a > 0 && (this._.range = a) }, get () { return this._.range } } }), d.bang = function () { return this._.prev = null, this._.emit('bang'), this }, d.at = function (a) { const b = this._; return 2 ** (a / b.range) }, d.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { this.tickID = a; let e; const f = this.nodes.length; const g = b.length; if (d.ar && f) { c.inputSignalAR(this); const h = d.range; for (e = 0; g > e; ++e) { b[e] = 2 ** (b[e] / h) }d.value = b[g - 1], c.outputSignalAR(this) } else { const i = this.nodes.length ? c.inputSignalKR(this) : d.midi; d.prev !== i && (d.prev = i, d.value = 2 ** (i / d.range)); const j = d.value * d.mul + d.add; for (e = 0; g > e; ++e) { b[e] = j } } } return this }, c.register('midiratio', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b) } const c = a.fn; c.extend(b); const d = b.prototype; d.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { this.tickID = a; let e; let f; let g; let h; const i = this.nodes; const j = i.length; const k = b.length; if (d.ar) { if (i.length > 0) { for (g = i[0].process(a).cells[0], b.set(g), e = 1; j > e; ++e) { for (g = i[e].process(a).cells[0], f = 0; k > f; ++f) { h = g[f], b[f] > h && (b[f] = h) } } } else { for (f = 0; k > f; ++f) { b[f] = 0 } }c.outputSignalAR(this) } else { if (i.length > 0) { for (g = i[0].process(a).cells[0][0], e = 1; j > e; ++e) { h = i[e].process(a).cells[0][0], g > h && (g = h) } } else { g = 0 }b[0] = g, c.outputSignalKR(this) } } return this }, c.register('min', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 0, b), c.timer(this), c.fixKR(this); const e = this._; e.tracks = [], e.onended = c.make_onended(this), e.currentTime = 0, this.on('start', d) } var c = a.fn; c.extend(b); var d = function () { const a = this; const b = this._; let d = b.mml; typeof d === 'string' && (d = [d]), b.tracks = d.map(function (b, c) { return new f(a, c, b) }), b.currentTime = 0, this.playbackState = c.PLAYING_STATE }; Object.defineProperty(d, 'unremoved', { value: !0, writable: !1 }); const e = b.prototype; Object.defineProperties(e, { mml: { set (a) { const b = this._; (typeof a === 'string' || Array.isArray(a)) && (b.mml = a) }, get () { return this._.mml } }, currentTime: { get () { return this._.currentTime } } }), e.on = e.addListener = function (a, b) { return a === 'mml' && (a = 'data', console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener.")), this._.events.on(a, b), this }, e.once = function (a, b) { return a === 'mml' && (a = 'data', console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener.")), this._.events.once(a, b), this }, e.off = e.removeListener = function (a, b) { return a === 'mml' && (a = 'data', console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener.")), this._.events.off(a, b), this }, e.removeAllListeners = function (a) { return a === 'mml' && (console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener."), a = 'data'), this._.events.removeAllListeners(a), this }, e.listeners = function (a) { return a === 'mml' && (console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener."), a = 'data'), this._.events.listeners(a) }, e.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; let e; const f = b.tracks; for (d = 0, e = f.length; e > d; ++d) { f[d].process() } for (;d--;) { f[d].ended && f.splice(d, 1) }f.length === 0 && c.nextTick(b.onended), b.currentTime += c.currentTimeIncr } return this }, c.register('mml', b); var f = (function () { function a (a, b, c) { const d = this._ = {}; d.sequencer = a, d.trackNum = b, d.commands = k(c), d.status = { t: 120, l: 4, o: 4, v: 12, q: 6, dot: 0, tie: !1 }, d.index = 0, d.queue = [], d.currentTime = 0, d.queueTime = 0, d.segnoIndex = -1, d.loopStack = [], d.prevNote = 0, d.remain = 1 / 0, this.ended = !1, j(this) } const b = 0; const d = 1; const e = 2; const f = 3; a.prototype.process = function () { const a = this._; const k = a.sequencer; const l = a.trackNum; const m = a.queue; let n = !1; if (m.length) { for (;m[0][0] <= a.currentTime;) { const o = a.queue.shift(); switch (o[1]) { case d:g(k, l, o[2], o[3]), a.remain = o[4], j(this); break; case e:h(k, l, o[2], o[3]); break; case f:i(k, o[2]); break; case b:n = !0 } if (m.length === 0) { break } } }a.remain -= c.currentTimeIncr, n && (this.ended = !0), a.currentTime += c.currentTimeIncr }; var g = function (a, b, c, d) { let e; let f; let g; const h = a.nodes; for (f = 0, g = h.length; g > f; ++f) { e = h[f], e.noteOn ? e.noteOn(c, d) : e.bang() }a._.emit('data', 'noteOn', { trackNum: b, noteNum: c, velocity: d }) }; var h = function (a, b, c, d) { let e; let f; let g; const h = a.nodes; for (f = 0, g = h.length; g > f; ++f) { e = h[f], e.noteOff ? e.noteOff(c, d) : e.release && e.release() }a._.emit('data', 'noteOff', { trackNum: b, noteNum: c, velocity: d }) }; var i = function (a, b) { a._.emit('data', 'command', { command: b }) }; var j = function (a) { let c; let g; let h; let i; let j; let k; let l; let m; let n; let o; let p; let q; let r; const s = a._; const t = (s.sequencer, s.commands); const u = s.queue; let v = s.index; const w = s.status; let x = s.queueTime; const y = s.loopStack; n = []; a:for (;;) { if (t.length <= v) { if (!(s.segnoIndex >= 0)) { break } v = s.segnoIndex } switch (c = t[v++], c.name) { case '@':u.push([x, f, c.val]); break; case 'n':if (g = w.t || 120, c.len !== null ? (i = c.len, j = c.dot || 0) : (i = w.l, j = c.dot || w.dot), l = 60 / g * (4 / i) * 1e3, l *= [1, 1.5, 1.75, 1.875][j] || 1, k = w.v << 3, w.tie) { for (q = u.length; q--;) { if (u[q][2]) { u.splice(q, 1); break } }h = s.prevNote } else { h = s.prevNote = c.val + 12 * (w.o + 1), u.push([x, d, h, k, l]) } if (i > 0) { if (m = w.q / 8, m < 1) { for (o = x + l * m, u.push([o, e, h, k]), q = 0, r = n.length; r > q; ++q) { u.push([o, e, n[q], k]) } } if (n = [], x += l, !w.tie) { break a } } else { n.push(h) }w.tie = !1; break; case 'r':g = w.t || 120, c.len !== null ? (i = c.len, j = c.dot || 0) : (i = w.l, j = c.dot || w.dot), i > 0 && (l = 60 / g * (4 / i) * 1e3, l *= [1, 1.5, 1.75, 1.875][j] || 1, x += l); break; case 'l':w.l = c.val, w.dot = c.dot; break; case 'o':w.o = c.val; break; case '<':w.o < 9 && (w.o += 1); break; case '>':w.o > 0 && (w.o -= 1); break; case 'v':w.v = c.val; break; case '(':w.v < 15 && (w.v += 1); break; case ')':w.v > 0 && (w.v -= 1); break; case 'q':w.q = c.val; break; case '&':w.tie = !0; break; case '$':s.segnoIndex = v; break; case '[':y.push([v, null, null]); break; case '|':p = y[y.length - 1], p && p[1] === 1 && (y.pop(), v = p[2]); break; case ']':p = y[y.length - 1], p && (p[1] === null && (p[1] = c.count, p[2] = v), p[1] -= 1, p[1] === 0 ? y.pop() : v = p[0]); break; case 't':w.t = c.val === null ? 120 : c.val; break; case 'EOF':u.push([x, b]) } }s.index = v, s.queueTime = x }; var k = function (a) { let b; let c; let d; let e; let f; let g; let h; let i; const j = new Array(a.length); const k = []; for (f = 0, g = l.length; g > f; ++f) { for (b = l[f], c = b.re; d = c.exec(a);) { if (!j[d.index]) { for (h = 0, i = d[0].length; i > h; ++h) { j[d.index + h] = !0 }e = b.func ? b.func(d) : { name: d[0] }, e && (e.index = d.index, e.origin = d[0], k.push(e)) } for (;c.lastIndex < a.length && j[c.lastIndex];) { ++c.lastIndex } } } return k.sort(function (a, b) { return a.index - b.index }), k.push({ name: 'EOF' }), k }; var l = [{ re: /@(\d*)/g, func (a) { return { name: '@', val: a[1] || null } } }, { re: /([cdefgab])([\-+]?)(\d*)(\.*)/g, func (a) { return { name: 'n', val: { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }[a[1]] + ({ '-': -1, '+': 1 }[a[2]] || 0), len: a[3] === '' ? null : Math.min(0 | a[3], 64), dot: a[4].length } } }, { re: /r(\d*)(\.*)/g, func (a) { return { name: 'r', len: a[1] === '' ? null : Math.max(1, Math.min(0 | a[1], 64)), dot: a[2].length } } }, { re: /&/g }, { re: /l(\d*)(\.*)/g, func (a) { return { name: 'l', val: a[1] === '' ? 4 : Math.min(0 | a[1], 64), dot: a[2].length } } }, { re: /o([0-9])/g, func (a) { return { name: 'o', val: a[1] === '' ? 4 : 0 | a[1] } } }, { re: /[<>]/g }, { re: /v(\d*)/g, func (a) { return { name: 'v', val: a[1] === '' ? 12 : Math.min(0 | a[1], 15) } } }, { re: /[()]/g }, { re: /q([0-8])/g, func (a) { return { name: 'q', val: a[1] === '' ? 6 : Math.min(0 | a[1], 8) } } }, { re: /\[/g }, { re: /\|/g }, { re: /\](\d*)/g, func (a) { return { name: ']', count: 0 | a[1] || 2 } } }, { re: /t(\d*)/g, func (a) { return { name: 't', val: a[1] === '' ? null : Math.max(5, Math.min(0 | a[1], 300)) } } }, { re: /\$/g }]; return a }()) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b) } const c = a.fn; c.extend(b), b.prototype.process = function (a) { const b = this._; return this.tickID !== a && (this.tickID = a, b.ar ? (c.inputSignalAR(this), c.outputSignalAR(this)) : (this.cells[0][0] = c.inputSignalKR(this), c.outputSignalKR(this))), this }, c.register('mono', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b) } const c = a.fn; c.extend(b); const d = b.prototype; d.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; let e; let f; let g; let h; const i = this.nodes; const j = this.cells[0]; const k = this.cells[1]; const l = this.cells[2]; const m = i.length; const n = j.length; if (b.ar) { if (i.length > 0) { for (i[0].process(a), g = i[0].cells[1], h = i[0].cells[2], k.set(g), l.set(h), d = 1; m > d; ++d) { for (i[d].process(a), g = i[d].cells[1], h = i[d].cells[2], e = 0; n > e; ++e) { k[e] *= g[e], l[e] *= h[e] } } } else { for (e = 0; n > e; ++e) { k[e] = l[e] = 0 } }c.outputSignalAR(this) } else { if (i.length > 0) { for (f = i[0].process(a).cells[0][0], d = 1; m > d; ++d) { f *= i[d].process(a).cells[0][0] } } else { f = 0 }j[0] = f, c.outputSignalKR(this) } } return this }, c.register('*', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b); const c = this._; c.defaultValue = 0, c.index = 0, c.dict = {}, c.ar = !1 } const c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { dict: { set (a) { if (typeof a === 'object') { this._.dict = a } else if (typeof a === 'function') { for (var b = {}, c = 0; c < 128; ++c) { b[c] = a(c) } this._.dict = b } }, get () { return this._.dict } }, defaultValue: { set (a) { typeof a === 'number' && (this._.defaultValue = a) }, get () { return this._.defaultValue } }, index: { set (a) { typeof a === 'number' && (this._.index = a) }, get () { return this._.index } } }), d.at = function (a) { const b = this._; return (b.dict[0 | a] || b.defaultValue) * b.mul + b.add }, d.clear = function () { return this._.dict = {}, this }, d.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { this.tickID = a; let e; let f; let g; const h = this.nodes.length; const i = d.dict; const j = d.defaultValue; const k = d.mul; const l = d.add; const m = b.length; if (d.ar && h) { for (c.inputSignalAR(this), g = 0; m > g; ++g) { e = b[g], e = e < 0 ? e - 0.5 | 0 : e + 0.5 | 0, b[g] = (i[e] || j) * k + l }c.outputSignalAR(this) } else { for (e = this.nodes.length ? c.inputSignalKR(this) : d.index, e = e < 0 ? e - 0.5 | 0 : e + 0.5 | 0, f = (i[e] || j) * k + l, g = 0; m > g; ++g) { b[g] = f } } } return this }, c.register('ndict', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b) } const c = a.fn; c.extend(b); const d = b.prototype; d.process = function (a) { const b = this.cells[0]; const c = this._; if (this.tickID !== a) { this.tickID = a; let d; let e; let f; const g = c.mul; const h = c.add; if (c.ar) { for (d = 0, e = b.length; e > d; ++d) { b[d] = (2 * Math.random() - 1) * g + h } } else { for (f = (2 * Math.random() + 1) * g + h, d = 0, e = b.length; e > d; ++d) { b[d] = f } } } return this }, c.register('noise', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b); const d = this._; d.freq = a(440), d.phase = a(0), d.osc = new e(d.samplerate), d.tmp = new c.SignalArray(d.cellsize), d.osc.step = d.cellsize, this.once('init', f) } var c = a.fn; const d = a.timevalue; var e = a.modules.Oscillator; c.extend(b); var f = function () { const a = this._; this.wave || (this.wave = 'sin'), a.plotData = a.osc.wave, a.plotLineWidth = 2, a.plotCyclic = !0, a.plotBefore = h }; const g = b.prototype; Object.defineProperties(g, { wave: { set (a) { this._.osc.setWave(a) }, get () { return this._.osc.wave } }, freq: { set (b) { typeof b === 'string' && (b = d(b), b = b <= 0 ? 0 : 1e3 / b), this._.freq = a(b) }, get () { return this._.freq } }, phase: { set (b) { this._.phase = a(b), this._.osc.feedback = !1 }, get () { return this._.phase } }, fb: { set (b) { this._.phase = a(b), this._.osc.feedback = !0 }, get () { return this._.phase } } }), g.clone = function () { const a = c.clone(this); return a._.osc = this._.osc.clone(), a._.freq = this._.freq, a._.phase = this._.phase, a }, g.bang = function () { return this._.osc.reset(), this._.emit('bang'), this }, g.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; const e = this.cells[1]; const f = this.cells[2]; const g = b.cellsize; if (this.nodes.length) { c.inputSignalAR(this) } else { for (d = 0; g > d; ++d) { e[d] = f[d] = 1 } } const h = b.osc; const i = b.freq.process(a).cells[0]; const j = b.phase.process(a).cells[0]; if (h.frequency = i[0], h.phase = j[0], b.ar) { const k = b.tmp; for (b.freq.isAr ? b.phase.isAr ? h.processWithFreqAndPhaseArray(k, i, j) : h.processWithFreqArray(k, i) : b.phase.isAr ? h.processWithPhaseArray(k, j) : h.process(k), d = 0; g > d; ++d) { e[d] *= k[d], f[d] *= k[d] } } else { const l = h.next(); for (d = 0; g > d; ++d) { e[d] *= l, f[d] *= l } }c.outputSignalAR(this) } return this }; let h; a.envtype === 'browser' && (h = function (a, b, c, d, e) { const f = (e >> 1) + 0.5; a.strokeStyle = '#ccc', a.lineWidth = 1, a.beginPath(), a.moveTo(b, f + c), a.lineTo(b + d, f + c), a.stroke() }), c.register('osc', b), c.register('sin', function (a) { return new b(a).set('wave', 'sin') }), c.register('cos', function (a) { return new b(a).set('wave', 'cos') }), c.register('pulse', function (a) { return new b(a).set('wave', 'pulse') }), c.register('tri', function (a) { return new b(a).set('wave', 'tri') }), c.register('saw', function (a) { return new b(a).set('wave', 'saw') }), c.register('fami', function (a) { return new b(a).set('wave', 'fami') }), c.register('konami', function (a) { return new b(a).set('wave', 'konami') }), c.register('+sin', function (a) { return new b(a).set('wave', '+sin').kr() }), c.register('+pulse', function (a) { return new b(a).set('wave', '+pulse').kr() }), c.register('+tri', function (a) { return new b(a).set('wave', '+tri').kr() }), c.register('+saw', function (a) { return new b(a).set('wave', '+saw').kr() }), c.alias('square', 'pulse') }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; d.pos = a(0), d.panL = 0.5, d.panR = 0.5 } var c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { pos: { set (b) { this._.pos = a(b) }, get () { return this._.pos } } }), d.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; const d = b.pos.process(a).cells[0][0]; if (b.prevPos !== d) { b.panL = 1 - d, b.panR = b.prevPos = d } let e; let f; let g; const h = this.nodes; const i = this.cells[1]; const j = this.cells[2]; const k = h.length; const l = i.length; if (k) { for (g = h[0].process(a).cells[0], f = 0; l > f; ++f) { i[f] = j[f] = g[f] } for (e = 1; k > e; ++e) { for (g = h[e].process(a).cells[0], f = 0; l > f; ++f) { i[f] = j[f] += g[f] } } const m = b.panL; const n = b.panR; for (f = 0; l > f; ++f) { i[f] = i[f] * m, j[f] = j[f] * n } } else { i.set(c.emptycell), j.set(c.emptycell) }c.outputSignalAR(this) } return this }, c.register('pan', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b); const c = this._; c.value = 0, c.env = new f(c.samplerate), c.env.step = c.cellsize, c.curve = 'lin', c.counter = 0, c.ar = !1, c.onended = g(this), this.on('ar', h) } const c = a.fn; const d = a.timevalue; const e = a.modules.Envelope; var f = a.modules.EnvelopeValue; c.extend(b); var g = function (a, b) { return function () { if (typeof b === 'number') { for (let c = a.cells[0], d = a.cells[1], e = a.cells[2], f = a._.env.value, g = 0, h = d.length; h > g; ++g) { c[0] = d[g] = e[g] = f } }a._.emit('ended') } }; var h = function (a) { this._.env.step = a ? 1 : this._.cellsize }; const i = b.prototype; Object.defineProperties(i, { value: { set (a) { typeof a === 'number' && (this._.env.value = a) }, get () { return this._.env.value } } }), i.to = function (a, b, c) { const f = this._; const g = f.env; if (typeof b === 'string' ? b = d(b) : typeof b === 'undefined' && (b = 0), typeof c === 'undefined') { f.counter = g.setNext(a, b, e.CurveTypeLin), f.curve = 'lin' } else { const h = e.CurveTypeDict[c]; f.counter = typeof h === 'undefined' ? g.setNext(a, b, e.CurveTypeCurve, c) : g.setNext(a, b, h), f.curve = c } return f.plotFlush = !0, this }, i.setAt = function (a, b) { const c = this._; return this.to(c.env.value, b, 'set'), c.atValue = a, this }, i.linTo = function (a, b) { return this.to(a, b, 'lin') }, i.expTo = function (a, b) { return this.to(a, b, 'exp') }, i.sinTo = function (a, b) { return this.to(a, b, 'sin') }, i.welTo = function (a, b) { return this.to(a, b, 'wel') }, i.sqrTo = function (a, b) { return this.to(a, b, 'sqr') }, i.cubTo = function (a, b) { return this.to(a, b, 'cub') }, i.cancel = function () { const a = this._; return a.counter = a.env.setNext(a.env.value, 0, e.CurveTypeSet), this }, i.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; let f; const g = this.cells[1]; const h = this.cells[2]; const i = b.cellsize; const j = b.env; const k = b.counter; if (this.nodes.length) { c.inputSignalAR(this) } else { for (d = 0; i > d; ++d) { g[d] = h[d] = 1 } } if (k <= 0 && (b.curve === 'set' ? j.setNext(b.atValue, 0, e.CurveTypeSet) : j.setNext(j.value, 0, e.CurveTypeSet), c.nextTick(b.onended), b.counter = 1 / 0), b.ar) { for (d = 0; i > d; ++d) { f = j.next(), g[d] *= f, h[d] *= f }b.counter -= b.cellsize } else { for (f = j.next(), d = 0; i > d; ++d) { g[d] *= f, h[d] *= f }b.counter -= 1 }c.outputSignalAR(this), b.value = f } return this }; const j = a.Object.prototype.plot; i.plot = function (a) { const b = this._; if (b.plotFlush) { let c; let d; let g; const h = new f(128); const i = new Float32Array(128); if (b.curve === 'set') { for (d = 100, g = i.length; g > d; ++d) { i[d] = 1 } } else { for (c = e.CurveTypeDict[b.curve], typeof c === 'undefined' ? h.setNext(1, 1e3, e.CurveTypeCurve, b.curve) : h.setNext(1, 1e3, c), d = 0, g = i.length; g > d; ++d) { i[d] = h.next() } }b.plotData = i, b.plotRange = [0, 1], b.plotFlush = null } return j.call(this, a) }, c.register('param', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; d.freq = a('sin', { freq: 1, add: 1e3, mul: 250 }).kr(), d.Q = a(1), d.allpass = [], this.steps = 2 } var c = a.fn; const d = a.modules.Biquad; c.extend(b); const e = b.prototype; Object.defineProperties(e, { freq: { set (a) { this._.freq = a }, get () { return this._.freq } }, Q: { set (b) { this._.Q = a(b) }, get () { return this._.Q } }, steps: { set (a) { if (typeof a === 'number') { if (a |= 0, a === 2 || a === 4 || a === 8 || a === 12) { const b = this._.allpass; if (b.length < a) { for (let c = b.length; a > c; ++c) { b[c] = new d(this._.samplerate), b[c].setType('allpass') } } } this._.steps = a } }, get () { return this._.steps } } }), e.process = function (a) { const b = this._; if (this.tickID !== a) { if (this.tickID = a, c.inputSignalAR(this), !b.bypassed) { let d; const e = this.cells[1]; const f = this.cells[2]; const g = b.freq.process(a).cells[0][0]; const h = b.Q.process(a).cells[0][0]; const i = b.steps; for (d = 0; i > d; d += 2) { b.allpass[d].setParams(g, h, 0), b.allpass[d].process(e, f), b.allpass[d + 1].setParams(g, h, 0), b.allpass[d + 1].process(e, f) } }c.outputSignalAR(this) } return this }, c.register('phaser', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), d.fixAR(this); for (var c = new Uint8Array(5), e = 0; e < 5; ++e) { c[e] = (Math.random() * (1 << 30) | 0) % 25 } this._.whites = c, this._.key = 0 } const c = 31; var d = a.fn; d.extend(b); const e = b.prototype; e.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { this.tickID = a; let e; let f; let g; let h; let i; let j; let k = d.key; const l = d.whites; const m = d.mul; const n = d.add; for (e = 0, f = b.length; f > e; ++e) { for (h = k++, k > c && (k = 0), j = h ^ k, g = i = 0; g < 5; ++g) { j & 1 << g && (l[g] = (Math.random() * (1 << 30) | 0) % 25), i += l[g] }b[e] = (0.01666666 * i - 1) * m + n }d.key = k } return this }, d.register('pink', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), this._.freq = 440, this._.buffer = null, this._.index = 0 } const c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { freq: { set (a) { typeof a === 'number' && (a < 0 && (a = 0), this._.freq = a) }, get () { return this._.freq } } }), d.bang = function () { for (var a = this._, b = a.freq, d = a.samplerate / b + 0.5 | 0, e = a.buffer = new c.SignalArray(d), f = 0; d > f; ++f) { e[f] = 2 * Math.random() - 1 } return a.index = 0, a.emit('bang'), this }, d.process = function (a) { const b = this.cells[0]; const c = this._; if (this.tickID !== a) { this.tickID = a; const d = c.buffer; if (d) { let e; let f; let g; const h = d.length; let i = c.index; const j = c.mul; const k = c.add; const l = b.length; for (g = 0; l > g; ++g) { e = i, f = d[i++], i >= h && (i = 0), f = 0.5 * (f + d[i]), d[e] = f, b[g] = f * j + k }c.index = i } } return this }, c.register('pluck', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), c.listener(this), c.fixAR(this); const d = this._; d.timeout = 5e3, d.status = e, d.writeIndex = 0, d.writeIndexIncr = 1, d.currentTime = 0, d.currentTimeIncr = 1e3 / d.samplerate, d.onended = g(this) } var c = a.fn; const d = a.timevalue; var e = 0; const f = 1; c.extend(b); var g = function (a) { return function () { const b = a._; const d = new c.SignalArray(b.buffer.subarray(0, 0 | b.writeIndex)); b.status = e, b.writeIndex = 0, b.currentTime = 0, b.emit('ended', { buffer: d, samplerate: b.samplerate }) } }; const h = b.prototype; Object.defineProperties(h, { timeout: { set (a) { typeof a === 'string' && (a = d(a)), typeof a === 'number' && a > 0 && (this._.timeout = a) }, get () { return this._.timeout } }, samplerate: { set (a) { typeof a === 'number' && a > 0 && a <= this._.samplerate && (this._.samplerate = a) }, get () { return this._.samplerate } }, currentTime: { get () { return this._.currentTime } } }), h.start = function () { let b; const d = this._; return d.status === e && (b = 0.01 * d.timeout * d.samplerate | 0, (!d.buffer || d.buffer.length < b) && (d.buffer = new c.SignalArray(b)), d.writeIndex = 0, d.writeIndexIncr = d.samplerate / a.samplerate, d.currentTime = 0, d.status = f, d.emit('start'), this.listen()), this }, h.stop = function () { const a = this._; return a.status === f && (a.status = e, a.emit('stop'), c.nextTick(a.onended), this.unlisten()), this }, h.bang = function () { return this._.status === e ? this.srart() : this._.status === f && this.stop(), this._.emit('bang'), this }, h.process = function (a) { const b = this._; const d = this.cells[0]; if (this.tickID !== a) { if (this.tickID = a, c.inputSignalAR(this), b.status === f) { let e; const g = d.length; const h = b.buffer; const i = b.timeout; let j = b.writeIndex; const k = b.writeIndexIncr; let l = b.currentTime; const m = b.currentTimeIncr; for (e = 0; g > e; ++e) { h[0 | j] = d[e], j += k, l += m, l >= i && c.nextTick(b.onended) }b.writeIndex = j, b.currentTime = l }c.outputSignalAR(this) } return this }, c.register('record', b), c.alias('rec', 'record') }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this), this._.reverb = new d(this._.samplerate, this._.cellsize) } var c = a.fn; var d = a.modules.Reverb; c.extend(b); const e = b.prototype; Object.defineProperties(e, { room: { set (a) { typeof a === 'number' && (a = a > 1 ? 1 : a < 0 ? 0 : a, this._.reverb.setRoomSize(a)) }, get () { return this._.reverb.roomsize } }, damp: { set (a) { typeof a === 'number' && (a = a > 1 ? 1 : a < 0 ? 0 : a, this._.reverb.setDamp(a)) }, get () { return this._.reverb.damp } }, mix: { set (a) { typeof a === 'number' && (a = a > 1 ? 1 : a < 0 ? 0 : a, this._.reverb.wet = a) }, get () { return this._.reverb.wet } } }), e.process = function (a) { const b = this._; return this.tickID !== a && (this.tickID = a, c.inputSignalAR(this), b.bypassed || b.reverb.process(this.cells[1], this.cells[2]), c.outputSignalAR(this)), this }, c.register('reverb', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 0, b), c.timer(this), c.fixKR(this); const d = this._; d.queue = [], d.currentTime = 0, d.maxRemain = 1e3 } var c = a.fn; const d = a.timevalue; c.extend(b); const e = b.prototype; Object.defineProperties(e, { queue: { get () { return this._.queue } }, remain: { get () { return this._.queue.length } }, maxRemain: { set (a) { typeof a === 'number' && a > 0 && (this._.maxRemain = a) }, get () { return this._.maxRemain } }, isEmpty: { get () { return this._.queue.length === 0 } }, currentTime: { get () { return this._.currentTime } } }), e.sched = function (a, b, c) { return typeof a === 'string' && (a = d(a)), typeof a === 'number' && this.schedAbs(this._.currentTime + a, b, c), this }, e.schedAbs = function (b, c, e) { if (typeof b === 'string' && (b = d(b)), typeof b === 'number') { const f = this._; const g = f.queue; if (g.length >= f.maxRemain) { return this } for (var h = g.length; h-- && !(g[h][0] < b);) { ; }g.splice(h + 1, 0, [b, a(c), e]) } return this }, e.advance = function (a) { return typeof a === 'string' && (a = d(a)), typeof a === 'number' && (this._.currentTime += a), this }, e.clear = function () { return this._.queue.splice(0), this }, e.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d = null; const e = b.queue; if (e.length) { for (;e[0][0] < b.currentTime;) { const f = b.queue.shift(); if (f[1].bang(f[2]), d = 'sched', e.length === 0) { d = 'empty'; break } } }b.currentTime += c.currentTimeIncr, d && b.emit(d) } return this }, c.register('schedule', b), c.alias('sched', 'schedule') }(timbre)), (function (a) {
  'use strict'; function b (b) { a.Object.call(this, 2, b), c.listener(this), c.fixAR(this); const d = this._; d.samples = 0, d.writeIndex = 0, d.plotFlush = !0, this.once('init', e) } var c = a.fn; const d = a.timevalue; c.extend(b); var e = function () { this._.buffer || (this.size = 1024), this._.interval || (this.interval = 1e3) }; const f = b.prototype; Object.defineProperties(f, { size: { set (a) { const b = this._; if (!b.buffer && typeof a === 'number') { const d = a < 64 ? 64 : a > 2048 ? 2048 : a; b.buffer = new c.SignalArray(d), b.reservedinterval && (this.interval = b.reservedinterval, b.reservedinterval = null) } }, get () { return this._.buffer.length } }, interval: { set (a) { const b = this._; typeof a === 'string' && (a = d(a)), typeof a === 'number' && a > 0 && (b.buffer ? (b.interval = a, b.samplesIncr = 0.001 * a * b.samplerate / b.buffer.length, b.samplesIncr < 1 && (b.samplesIncr = 1)) : b.reservedinterval = a) }, get () { return this._.interval } }, buffer: { get () { return this._.buffer } } }), f.bang = function () { for (var a = this._, b = a.buffer, c = 0, d = b.length; d > c; ++c) { b[c] = 0 } return a.samples = 0, a.writeIndex = 0, this._.emit('bang'), this }, f.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a, c.inputSignalAR(this), c.outputSignalAR(this); let d; const e = this.cells[0]; const f = b.cellsize; let g = b.samples; const h = b.samplesIncr; const i = b.buffer; let j = b.writeIndex; let k = !1; const l = i.length; for (d = 0; f > d; ++d) { g <= 0 && (i[j++] = e[d], j >= l && (j = 0), k = b.plotFlush = !0, g += h), --g } b.samples = g, b.writeIndex = j, k && this._.emit('data') } return this }; const g = a.Object.prototype.plot; f.plot = function (a) {
    const b = this._; if (b.plotFlush) {
      for (var c = b.buffer, d = c.length - 1, e = new Float32Array(c.length), f = b.writeIndex, h = 0, i = c.length; i > h; h++) { e[h] = c[++f & d] }
      b.plotData = e, b.plotFlush = null
    } return g.call(this, a)
  }, c.register('scope', b)
}(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), e.fixAR(this); const c = this._; c.numberOfInputs = 0, c.numberOfOutputs = 0, c.bufferSize = 0, c.bufferMask = 0, c.duration = 0, c.inputBufferL = null, c.inputBufferR = null, c.outputBufferL = null, c.outputBufferR = null, c.onaudioprocess = null, c.index = 0, this.once('init', f) } function c (a, b) { this.samplerate = a._.samplerate, this.length = a._.bufferSize, this.duration = a._.duration, this.numberOfChannels = b.length, this.getChannelData = function (a) { return b[a] } } function d (b) { const d = b._; this.node = b, this.playbackTime = a.currentTime, this.inputBuffer = d.numberOfInputs === 2 ? new c(b, [d.inputBufferL, d.inputBufferR]) : new c(b, [d.inputBufferL]), this.outputBuffer = d.numberOfOutputs === 2 ? new c(b, [d.outputBufferL, d.outputBufferR]) : new c(b, [d.outputBufferL]) } var e = a.fn; e.extend(b); var f = function () { const a = this._; a.numberOfInputs === 0 && (this.numberOfInputs = 1), a.numberOfOutputs === 0 && (this.numberOfOutputs = 1), a.bufferSize === 0 && (this.bufferSize = 1024) }; const g = b.prototype; Object.defineProperties(g, { numberOfInputs: { set (a) { const b = this._; b.numberOfInputs === 0 && (b.numberOfInputs = a === 2 ? 2 : 1) }, get () { return this._.numberOfInputs } }, numberOfOutputs: { set (a) { const b = this._; b.numberOfOutputs === 0 && (b.numberOfOutputs = a === 2 ? 2 : 1) }, get () { return this._.numberOfOutputs } }, bufferSize: { set (a) { const b = this._; b.bufferSize === 0 && [256, 512, 1024, 2048, 4096, 8192, 16384].includes(a) && (b.bufferSize = a, b.bufferMask = a - 1, b.duration = a / b.samplerate, b.inputBufferL = new e.SignalArray(a), b.inputBufferR = new e.SignalArray(a), b.outputBufferL = new e.SignalArray(a), b.outputBufferR = new e.SignalArray(a)) }, get () { return this._.bufferSize } }, onaudioprocess: { set (a) { typeof a === 'function' && (this._.onaudioprocess = a) }, get () { return this._.onaudioprocess } } }), g.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let c; const f = b.cellsize; const g = b.bufferMask; const h = b.index; const i = h + f; const j = this.cells[1]; const k = this.cells[2]; if (e.inputSignalAR(this), b.numberOfInputs === 2) { b.inputBufferL.set(j, h), b.inputBufferR.set(k, h) } else { c = b.inputBufferL; for (let l = 0; f > l; l++) { c[h + l] = 0.5 * (j[l] + k[l]) } }j.set(b.outputBufferL.subarray(h, i)), k.set(b.outputBufferR.subarray(h, i)), b.index = i & g, b.index === 0 && b.onaudioprocess && (b.onaudioprocess(new d(this)), b.numberOfOutputs === 1 && b.outputBufferR.set(b.outputBufferL)), e.outputSignalAR(this) } return this }, e.register('script', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), this._.selected = 0, this._.background = !1 } const c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { selected: { set (a) { typeof a === 'number' && (this._.selected = a, this.cells[1].set(c.emptycell), this.cells[2].set(c.emptycell)) }, get () { return this._.selected } }, background: { set (a) { this._.background = !!a }, get () { return this._.background } } }), d.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; const e = this.nodes; const f = e.length; if (b.background) { for (d = 0; f > d; ++d) { e[d].process(a) } } const g = e[b.selected]; g && (b.background || g.process(a), this.cells[1].set(g.cells[1]), this.cells[2].set(g.cells[2])), c.outputSignalAR(this) } return this }, c.register('selector', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.listener(this), c.fixAR(this); const d = this._; d.status = f, d.samples = 0, d.samplesIncr = 0, d.writeIndex = 0, d.plotFlush = !0, d.plotRange = [0, 32], d.plotBarStyle = !0, this.once('init', h) } var c = a.fn; const d = a.timevalue; const e = a.modules.FFT; var f = 0; const g = 1; c.extend(b); var h = function () { const a = this._; a.fft || (this.size = 512), a.interval || (this.interval = 500) }; const i = b.prototype; Object.defineProperties(i, { size: { set (a) { const b = this._; if (!b.fft && typeof a === 'number') { const d = a < 256 ? 256 : a > 2048 ? 2048 : a; b.fft = new e(d), b.buffer = new c.SignalArray(b.fft.length), b.freqs = new c.SignalArray(b.fft.length >> 1), b.reservedwindow && (b.fft.setWindow(b.reservedwindow), b.reservedwindow = null), b.reservedinterval && (this.interval = b.reservedinterval, b.reservedinterval = null) } }, get () { return this._.buffer.length } }, window: { set (a) { this._.fft.setWindow(a) }, get () { return this._.fft.windowName } }, interval: { set (a) { const b = this._; typeof a === 'string' && (a = d(a)), typeof a === 'number' && a > 0 && (b.buffer ? (b.interval = a, b.samplesIncr = 0.001 * a * b.samplerate, b.samplesIncr < b.buffer.length && (b.samplesIncr = b.buffer.length, b.interval = 1e3 * b.samplesIncr / b.samplerate)) : b.reservedinterval = a) }, get () { return this._.interval } }, spectrum: { get () { return this._.fft.getFrequencyData(this._.freqs) } }, real: { get () { return this._.fft.real } }, imag: { get () { return this._.fft.imag } } }), i.bang = function () { return this._.samples = 0, this._.writeIndex = 0, this._.emit('bang'), this }, i.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a, c.inputSignalAR(this), c.outputSignalAR(this); let d; let e; const h = this.cells[0]; const i = h.length; let j = b.status; let k = b.samples; const l = b.samplesIncr; let m = b.writeIndex; const n = b.buffer; const o = n.length; for (d = 0; i > d; ++d) { k <= 0 && j === f && (j = g, m = 0, k += l), j === g && (n[m++] = h[d], m >= o && (b.fft.forward(n), e = b.plotFlush = !0, j = f)), --k } b.samples = k, b.status = j, b.writeIndex = m, e && this._.emit('data') } return this }; const j = a.Object.prototype.plot; i.plot = function (a) { return this._.plotFlush && (this._.plotData = this.spectrum, this._.plotFlush = null), j.call(this, a) }, c.register('spectrum', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), this._.ar = !1 } const c = a.fn; c.extend(b); const d = b.prototype; d.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; let d; let e; let f; let g; let h; const i = this.nodes; const j = this.cells[0]; const k = this.cells[1]; const l = this.cells[2]; const m = i.length; const n = j.length; if (b.ar) { if (i.length > 0) { for (i[0].process(a), g = i[0].cells[1], h = i[0].cells[2], k.set(g), l.set(h), d = 1; m > d; ++d) { for (i[d].process(a), g = i[d].cells[1], h = i[d].cells[2], e = 0; n > e; ++e) { k[e] -= g[e], l[e] -= h[e] } } } else { for (e = 0; n > e; ++e) { k[e] = l[d] = 0 } }c.outputSignalAR(this) } else { if (i.length > 0) { for (f = i[0].process(a).cells[0][0], d = 1; m > d; ++d) { f -= i[d].process(a).cells[0][0] } } else { f = 0 }j[0] = f, c.outputSignalKR(this) } } return this }, c.register('-', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; this.playbackState = c.FINISHED_STATE, d.poly = 4, d.genList = [], d.genDict = {}, d.synthdef = null, d.remGen = f(this), d.onended = c.make_onended(this) } var c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { def: { set (a) { typeof a === 'function' && (this._.synthdef = a) }, get () { return this._.synthdef } }, poly: { set (a) { typeof a === 'number' && a > 0 && a <= 64 && (this._.poly = a) }, get () { return this._.poly } } }); const e = function (a, b) { return function () { a._.remGen(b.gen) } }; var f = function (a) { return function (b) { const c = a._; const d = c.genList.indexOf(b); d !== -1 && c.genList.splice(d, 1), typeof b.noteNum !== 'undefined' && (c.genDict[b.noteNum] = null) } }; const g = function (b, d, f, g) { f |= 0, f <= 0 ? this.noteOff(this, b) : f > 127 && (f = 127); const h = this._; const i = h.genList; const j = h.genDict; let k = j[b]; k && h.remGen(k); const l = { freq: d, noteNum: b, velocity: f, mul: 0.0078125 * f }; if (g) { for (const m in g) { l[m] = g[m] } }l.doneAction = e(this, l), k = h.synthdef.call(this, l), k instanceof a.Object && (k.noteNum = b, i.push(k), j[b] = l.gen = k, this.playbackState = c.PLAYING_STATE, i.length > h.poly && h.remGen(i[0])) }; const h = (function () { for (var a = new Float32Array(128), b = 0; b < 128; ++b) { a[b] = 440 * 2 ** (1 * (b - 69) / 12) } return a }()); const i = function (a) { return a > 0 ? Math.log(1 * a / 440) * Math.LOG2E * 12 + 69 : 0 }; d.noteOn = function (a, b, c) { const d = h[a] || 440 * 2 ** ((a - 69) / 12); return g.call(this, a + 0.5 | 0, d, b, c), this }, d.noteOff = function (a) { const b = this._.genDict[a]; return b && b.release && b.release(), this }, d.noteOnWithFreq = function (a, b, c) { const d = i(a); return g.call(this, d + 0.5 | 0, a, b, c), this }, d.noteOffWithFreq = function (a) { const b = i(a); return this.noteOff(b + 0.5 | 0) }, d.allNoteOff = function () { for (let a = this._.genList, b = 0, c = a.length; c > b; ++b) { a[b].release && a[b].release() } }, d.allSoundOff = function () { for (let a = this._, b = a.genList, c = a.genDict; b.length;) { delete c[b.shift().noteNum] } }, d.synth = function (b) { let d; const f = this._; const g = f.genList; const h = {}; if (b) { for (const i in b) { h[i] = b[i] } } return h.doneAction = e(this, h), d = f.synthdef.call(this, h), d instanceof a.Object && (g.push(d), h.gen = d, this.playbackState = c.PLAYING_STATE, g.length > f.poly && f.remGen(g[0])), this }, d.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { if (this.tickID = a, this.playbackState === c.PLAYING_STATE) { let e; let f; let g; let h; let i; let j; const k = d.genList; const l = this.cells[1]; const m = this.cells[2]; const n = b.length; if (k.length) { for (e = k[0], e.process(a), l.set(e.cells[1]), m.set(e.cells[2]), f = 1, g = k.length; g > f; ++f) { for (e = k[f], e.process(a), i = e.cells[1], j = e.cells[2], h = 0; n > h; ++h) { l[h] += i[h], m[h] += j[h] } } } else { c.nextTick(d.onended) } }c.outputSignalAR(this) } return this }, c.register('SynthDef', b); const j = { set (b) { c.isDictionary(b) ? typeof b.type === 'string' && (this._.env = b) : b instanceof a.Object && (this._.env = b) }, get () { return this._.env } }; c.register('OscGen', (function () { const c = { set (b) { b instanceof a.Object && (this._.osc = b) }, get () { return this._.osc } }; const d = { set (a) { typeof a === 'string' && (this._.wave = a) }, get () { return this._.wave } }; const e = function (b) { let c; let d; let e; let f; const g = this._; return d = g.osc || null, e = g.env || {}, f = e.type || 'perc', d instanceof a.Object && typeof d.clone === 'function' && (d = d.clone()), d || (d = a('osc', { wave: g.wave })), d.freq = b.freq, d.mul = d.mul * b.velocity / 128, c = d, e instanceof a.Object ? typeof e.clone === 'function' && (c = e.clone().append(c)) : c = a(f, e, c), c.on('ended', b.doneAction).bang(), c }; return function (a) { const f = new b(a); return f._.wave = 'sin', Object.defineProperties(f, { env: j, osc: c, wave: d }), f.def = e, f } }())), c.register('PluckGen', (function () { const c = function (b) { let c; let d; let e; const f = this._; return d = f.env || {}, e = d.type || 'perc', c = a('pluck', { freq: b.freq, mul: b.velocity / 128 }).bang(), d instanceof a.Object ? typeof d.clone === 'function' && (c = d.clone().append(c)) : c = a(e, d, c), c.on('ended', b.doneAction).bang(), c }; return function (a) { const d = new b(a); return Object.defineProperties(d, { env: j }), d.def = c, d } }())) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 2, b), c.fixAR(this); const d = this._; d.isLooped = !1, d.onended = c.make_onended(this, 0) } var c = a.fn; const d = a.modules.Scissor; const e = d.Tape; const f = d.TapeStream; const g = c.isSignalArray; c.extend(b); const h = b.prototype; Object.defineProperties(h, { tape: { set (b) { b instanceof e ? (this.playbackState = c.PLAYING_STATE, this._.tape = b, this._.tapeStream = new f(b, this._.samplerate), this._.tapeStream.isLooped = this._.isLooped) : (b instanceof a.Object && b.buffer && (b = b.buffer), typeof b === 'object' && Array.isArray(b.buffer) && g(b.buffer[0]) && (this.playbackState = c.PLAYING_STATE, this._.tape = new d(b), this._.tapeStream = new f(this._.tape, this._.samplerate), this._.tapeStream.isLooped = this._.isLooped)) }, get () { return this._.tape } }, isLooped: { get () { return this._.isLooped } }, buffer: { get () { return this._.tape ? this._.tape.getBuffer() : void 0 } } }), h.loop = function (a) { return this._.isLooped = !!a, this._.tapeStream && (this._.tapeStream.isLooped = this._.isLooped), this }, h.bang = function () { return this.playbackState = c.PLAYING_STATE, this._.tapeStream && this._.tapeStream.reset(), this._.emit('bang'), this }, h.getBuffer = function () { return this._.tape ? this._.tape.getBuffer() : void 0 }, h.process = function (a) { const b = this._; if (this.tickID !== a) { this.tickID = a; const d = b.tapeStream; if (d) { const e = this.cells[1]; const f = this.cells[2]; const g = d.fetch(e.length); e.set(g[0]), f.set(g[1]), this.playbackState === c.PLAYING_STATE && d.isEnded && c.nextTick(b.onended) }c.outputSignalAR(this) } return this }, c.register('tape', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), c.timer(this); const d = this._; this.playbackState = c.FINISHED_STATE, d.task = [], d.i = 0, d.j = 0, d.imax = 0, d.jmax = 0, d.wait = 0, d.count = 0, d.args = {}, d.doNum = 1, d.initFunc = c.nop, d.onended = g(this), this.on('start', f) } var c = a.fn; const d = a.timevalue; const e = a(function () {}).constructor; c.extend(b); var f = function () { let a; const b = this._; this.playbackState = c.PLAYING_STATE, b.task = this.nodes.map(function (a) { return a instanceof e ? a.func : !1 }).filter(function (a) { return !!a }), b.i = b.j = 0, b.imax = b.doNum, b.jmax = b.task.length, a = b.initFunc(), c.isDictionary(a) || (a = { param: a }), b.args = a }; var g = function (a) { return function () { a.playbackState = c.FINISHED_STATE; const b = a._; const d = a.cells[0]; const e = a.cells[1]; const f = a.cells[2]; const g = b.args; if (typeof g === 'number') { for (let h = 0, i = e.length; i > h; ++h) { d[0] = e[h] = f[h] = g } }b.emit('ended', b.args) } }; const h = b.prototype; Object.defineProperties(h, { do: { set (a) { typeof a === 'number' && a > 0 && (this._.doNum = 1 / 0 === a ? 1 / 0 : 0 | a) }, get () { return this._.doNum } }, init: { set (a) { typeof a === 'function' && (this._.initFunc = a) }, get () { return this._.initFunc } } }), h.bang = function () { const a = this._; return a.count = 0, a.emit('bang'), this }, h.wait = function (a) { return typeof a === 'string' && (a = d(a)), typeof a === 'number' && a > 0 && (this._.count += this._.samplerate * a * 0.001 | 0), this }, h.process = function (a) { let b; const d = this.cells[0]; const e = this._; if (this.tickID !== a && (this.tickID = a, e.i < e.imax)) { for (;e.count <= 0;) { if (e.j >= e.jmax) { if (++e.i, e.i >= e.imax) { c.nextTick(e.onended); break }e.j = 0 }b = e.task[e.j++], b && b.call(this, e.i, e.args) }e.count -= d.length } return this }, c.register('task', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 0, b), c.timer(this), c.fixKR(this); const d = this._; this.playbackState = c.FINISHED_STATE, d.currentTime = 0, d.samplesMax = 0, d.samples = 0, d.onended = c.make_onended(this), this.once('init', e), this.on('start', f) } var c = a.fn; const d = a.timevalue; c.extend(b); var e = function () { this._.timeout || (this.timeout = 1e3) }; var f = function () { this.playbackState = c.PLAYING_STATE }; Object.defineProperty(f, 'unremovable', { value: !0, writable: !1 }); const g = b.prototype; Object.defineProperties(g, { timeout: { set (a) { const b = this._; typeof a === 'string' && (a = d(a)), typeof a === 'number' && a >= 0 && (this.playbackState = c.PLAYING_STATE, b.timeout = a, b.samplesMax = 0.001 * b.samplerate * a | 0, b.samples = b.samplesMax) }, get () { return this._.timeout } }, currentTime: { get () { return this._.currentTime } } }), g.bang = function () { const a = this._; return this.playbackState = c.PLAYING_STATE, a.samples = a.samplesMax, a.currentTime = 0, a.emit('bang'), this }, g.process = function (a) { const b = this.cells[0]; const d = this._; if (this.tickID !== a) { if (this.tickID = a, d.samples > 0 && (d.samples -= b.length), d.samples <= 0) { for (let e = this.nodes, f = 0, g = e.length; g > f; ++f) { e[f].bang() }c.nextTick(d.onended) }d.currentTime += c.currentTimeIncr } return this }, c.register('timeout', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b), c.fixAR(this), this._.curve = null } var c = a.fn; c.extend(b); const d = b.prototype; Object.defineProperties(d, { curve: { set (a) { c.isSignalArray(a) && (this._.curve = a) }, get () { return this._.curve } } }), d.process = function (a) { const b = this._; if (this.tickID !== a) { if (this.tickID = a, c.inputSignalAR(this), b.curve) { let d; let e; const f = this.cells[0]; const g = b.curve; const h = g.length; const i = b.cellsize; for (e = 0; i > e; ++e) { d = 0.5 * (f[e] + 1) * h + 0.5 | 0, d < 0 ? d = 0 : d >= h - 1 && (d = h - 1), f[e] = g[d] } }c.outputSignalAR(this) } return this }, c.register('waveshaper', b) }(timbre)), (function (a) { 'use strict'; function b (b) { a.Object.call(this, 1, b); const c = this._; c.inMin = 0, c.inMax = 1, c.outMin = 0, c.outMax = 1, c.ar = !1, this.once('init', d) } const c = a.fn; c.extend(b); var d = function () { this._.warp || (this.warp = 'linlin') }; const e = b.prototype; Object.defineProperties(e, { inMin: { set (a) { typeof a === 'number' && (this._.inMin = a) }, get () { return this._.inMin } }, inMax: { set (a) { typeof a === 'number' && (this._.inMax = a) }, get () { return this._.inMax } }, outMin: { set (a) { typeof a === 'number' && (this._.outMin = a) }, get () { return this._.outMin } }, outMax: { set (a) { typeof a === 'number' && (this._.outMax = a) }, get () { return this._.outMax } }, warp: { set (a) { if (typeof a === 'string') { const b = f[a]; b && (this._.warp = b, this._.warpName = a) } }, get () { return this._.warpName } } }), e.process = function (a) { const b = this._; const d = this.cells[0]; if (this.tickID !== a) { this.tickID = a; let e; const f = b.inMin; const g = b.inMax; const h = b.outMin; const i = b.outMax; const j = b.warp; const k = this.nodes.length; const l = b.mul; const m = b.add; const n = d.length; if (b.ar && k) { for (c.inputSignalAR(this), e = 0; n > e; ++e) { d[e] = j(d[e], f, g, h, i) * l + m }c.outputSignalAR(this) } else { const o = this.nodes.length ? c.inputSignalKR(this) : 0; const p = j(o, f, g, h, i) * l + m; for (e = 0; n > e; ++e) { d[e] = p } } } return this }; var f = { linlin (a, b, c, d, e) { return b > a ? d : a > c ? e : c === b ? d : (a - b) / (c - b) * (e - d) + d }, linexp (a, b, c, d, e) { return b > a ? d : a > c ? e : d === 0 ? 0 : c === b ? e : (e / d) ** ((a - b) / (c - b)) * d }, explin (a, b, c, d, e) { return b > a ? d : a > c ? e : b === 0 ? e : Math.log(a / b) / Math.log(c / b) * (e - d) + d }, expexp (a, b, c, d, e) { return b > a ? d : a > c ? e : b === 0 || d === 0 ? 0 : (e / d) ** (Math.log(a / b) / Math.log(c / b)) * d } }; c.register('zmap', b) }(timbre))
// # sourceMappingURL=timbre.js.map
